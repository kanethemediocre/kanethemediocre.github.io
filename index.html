<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8"> 
    <title>Umo Space 167 by KaneTheMediocre</title>
    <style></style>
</head>
<body class="myElement" oncontextmenu="return false;">
    <canvas id="gameCanvas" width="1600" height="900"></canvas>
    <script>
        // declare variables
        const FPS = 30;
		setInterval(update, 1000 / FPS);// set up interval (game loop)
        var canvas, context;
        canvas = document.getElementById("gameCanvas"); //canvas is the draw sauce.
        context = canvas.getContext("2d");
		var time = 0; //Count of frames elapsed in game time.  Used to track in-game time related stuff.
		var system = 1; //0 is menu, 1 is home system.  Higher numbers eventually refer to procedurally generated systems.
		var thrustmultiplier = 1; //Adjusts thruster sensitivity
		var launchmultiplier = 1; //not really used
		var navtarget = 0; // Compass points to planets[navtarget]
		var navactive = 1; //nav computer starts off, 1 is planetary, 2 is for stations
		var shiptarget = 1; // Targets ships[1]
		var nmeactive = 1; //targeting computer starts off
		var mapactive = 2; //2 is corner map, 1 is full map, 0 is no map
		var mapscale = 128; //Map zoom
		var energy = 50;
		var thruster = 50;
		var money = 100;
		var gotmoney = [0,0]; //For animation, [$ amount, frames left in animation]
		var drawdistance = Math.sqrt(canvas.width*canvas.width/4+canvas.height*canvas.height/4)+200;
		var w1 = 1; //Presence or weapons, upgrades etc.
		var w2 = 0; //Upgraded weapons have values >1
		var w3 = 0; 
		var w4 = 0; 
		var w5 = 0;
		var w6 = 0;
		var w7 = 0;
		var w8 = 0;
		var w9 = 0;
		var w0 = 0;
		var mdx = 0;
		var mdy = 0;
		var wstatus = [w0,w1,w2,w3,w4,w5,w6,w7,w8,w9];//not used yet, index numbers match weapon numbers, will replace w# variables.
		var wnames = ["Probe","Blaster","Mine","Flakker","Railgun","SpreadShot", "Lazzzor","Double Rainbow","Spectral Disintigrator","Bapadoop"]; //also not used yet
		var a1 = 0; //armor upgrades
		var s1 = 0; //Shield upgrades
		var wep = 1; //Currently selected weapon
		var moused = 0; //Direction currently indicated by mouse
		var mousedistance = 0; // Distance to mouse cursor
		var mousestate = 0;
		var shop = 0; //O indicates not shopping, 1 indicates a shop, 2 might indicate a different shop....
        var shopitem = 0; //Indicates item selected in the shop.
		var storystate = 0;//Player progress in story missions
		var dockstate = 0; //Player dock status, 0 is undocked, 1 is docked at station 1, etc...
		var shipsinrange = [];//To help guide what ships are targetable by the player, I'm generating a short list / shallow copy of nearby ships.
		var radarrange = 4000;//Defines distance a ship can be from the player and still be targetable
		var closestdistance = 999999;//needs to be larger than radarrange 
		var closestindex = 0; //defaults to self-targeting if no ships in range
		var storytime = 0;//timestamp of last story event
		var storymessages = ["Well theres a fancy ship if I ever gave you one 10 seconds ago.  Let me show you the controls.  Flying and shooting is simple enough, right click for thrust, left click to shoot, and point the mouse in whatever direction you want to face.  Going anywhere in particular is more complicated, and if you wander around without a destination, you'll find what space is really made made of:  Nothing.",
		"You can cycle navigation modes with the N key.  Your nav computer can be off, targeting planets, or targeting stations.  The < and > keys will cycle through available nav targets.  The compass in the bottom right corner will point towards your nav target, and the name and distance.  The chart to the left gives more information if you're interested.  For now let's set the nav computer planetary mode, and select Merz.",
			//first check after 2 messages, navtarget==5 and navactive == 1
			"Great!  That's where you'll be going next.  But to help you know your place in the universe, your HUD also has a map.  The M key cycles between a full-screen display, a corner display, and off.  I recommend the corner.  You can zoom in and out with the + and - keys.",
			"The yellow rectangle in the center of the map is where you and the space you can see are located.  Planets, moons, and stations are drawn on the map, and planetary orbits are shown with grey lines.  Try zooming way out (- key) so that the whole system is in view.",
			//second check after 4 messages, zoom > some number
			"Nifty, right?  OK, so we're not going nearly that far away, so zoom back in on us and the inner planets.",
			//3rd check after 5 messages, zoom < some number
			"OK, so thats basically what you need to fly this burrito to Merz.  Just do a close flyby and then head back to The Merry Merzian.  The burrito will be delivered automagically.",
			//4th check after 6 messages, ships[0].distance(planets[5])<500
			"Good job.  Now get back to the Merry Merzian.  Remember you can use your nav computer to find the station.  When you're close you'll dock automatically.",
			//5th check after 7 messages, dockstate == 2
			"Alright, good job.  I suppose we should talk about the 'bots.  Most planets and moons have hostile Umobots.  They orbit their host planets and shoot at any ships that come near.  The Umobots around Merz aren't particularly dangerous, but each planet has it's own breed of bot, and most are more dangerous than the Merz bots.",
			"Bots can be destroyed, and in fact the Institute pays for their destruction, but replacements are never far behind.  Most space stations are built trailing or leading planets in their orbits around the their sun, because it keeps them farther away from the Umobots than orbiting the planet.  The Umobots don't chase after ships, and they only swarm around natural planetary bodies, so stations can be safe if they're not too close to a planet.",
			"No one knows where they came from, or why they suddenly started appearing 30 years ago.  But life off-world has changed dramatically since they came.  And not entirely for the worse--Most of your ships systems were developed by reverse engineering the remains of Umobots, and a whole new space industry has developed around both fighting and studying the 'bots",
			"You better learn a thing or two about combat before I send you anywhere more dangerous, eh?  The top left corner of your HUD has 4 important indicators.  At the top the green bar indicates your ship's health.  It's a basic measure of how close you are to blowing up.  Don't blow up.",
			"The next blue bar is your shield strength.  Your shield is a fast regenerating energy barrier that prevents your ship from being damaged by occasional minor hits.  Don't enter combat without a full shield, and get out if it ever goes down to 0.  A weak shield will still reduce the damage you take compared to no shield at all.",
			"The next red bar is your weapons energy.  The ship has capacitors to provide the burst current that the ships reactor can't directly provide.  The red bar indicates their energy level.",
			"Finally, the orange bar at the bottom shows your thruster energy level.  Just like your weapons, the ship's thrust capacitors recharge quickly with power from the reactor.  Don't get caught in a fight without any go-juice to spare for escape or evasive maneuvers.",
			"Below all of the status bars is an weapons indicator showing what weapon is selected.  Right now you've just got the basic blaster (weapon 1), but soon you'll be selecting them using the number keys (0-9)",
			"The last part of the HUD we need to talk about is the targeting computer.  Your radar can detect enemies within a certain distance (4000p), and often tell you useful information about them.  The [ and ] keys are used to cycle through available targets.  When in visual range, you'll also see a targeting reticle around your target.  The list of bots with names and distances is helpful if you're hunting a bot by name.",
			//respawn a bot in Merz orbit after 16 messages
			"Speaking of which, why don't you do me a favor and destroy a particular bot in Merz orbit?  The name is ",
			//display bots randomized name as part of 17th message.
			//check for ships[notsure].hp == -1000
			"Alright good job.  Now before you get carried away come back to the station and I'll fit your ship with something a little more powerful.",
			//after 18th message, check for dockstate == 2
			"Alright wait here for a moment while I work on your ship.  Your basic blaster, while not having any extraordinary capabilities, is energy efficient and effective for most situations.  The Mine launcher, is extraordinarily powerful but only useful in very special circumstances.  The Mine barely leaves your ship with any velocity of it's own, so you need to use your ship's velocity to throw it, then thrust away before impact.",
			"Firing the launcher again before the mine has detonated resets the mine in front of your ship, but you can switch back to your blaster after you've launched the mine.  The mine will persist for a full minute or when it hits something, whichever comes first.  New weapons an upgrades can be purchased at stations like the Merry Merzian, but I'm installing the mine launcher for free.  Go ahead and launch, it should be ready.",
			//after 20th message, check for dockstate ==0
			"OK now switch to weapon 2 and give it a shot.",
			//after 21st messsge, check for wep==2
			//check for bombs[1].timer>0 or something
			//set w2=0, and wep == 1
			"Hmm, that's not supposed to happen.  Dock back here again and I'll fix it.  I'll even give you a full refund.",
			//after 22nd message, check for dockstate==2
			"Huh, looks like it was a software problem all along.  OK, I promise next time it won't blow up in your face.  If it does I'll give you a double-refund on it. "
			]
		
		function showchart(chartdataxy, xspace, yspace, x,y){ //displays chart with specified cell dimensions and position
			 var i = 0 //assumes each column is same length, otherwise error
			 var j = 0;
			 while (i<chartdataxy.length){
				var cellposx = x+i*xspace;
				j = 0;
				while (j<chartdataxy[0].length){
					var cellposy = y+j*yspace;
					context.fillText(chartdataxy[i][j],cellposx,cellposy);
					j=j+1;
					}
				i=i+1;
				}
			 }
		//var cxytest = [ ["first", "column", "of", "words"], ["2nd", "column", "of", "words"]       ];
		//showchart(cxytest, 64, 16, 300,300);
		function showmessage(message){ //Displays a message, breaking it up into multiple lines as needed.  No word continuity or overflow handling yet.
			var maxlength = (canvas.width-820)/11; //estimating font width to 10 px, allotting 150 px margins
			var maxlines = canvas.height/(24*6); //estimating font height to 24 px, allotting 1/6 of screen, only used for overflow handling (eventually)
			var starty = Math.floor(canvas.height*5/6 - 24); //allotting bottom 1/6 of screen + 24 px fudge factor
			var startx = 408;
			var lines = 1 + Math.floor(message.length/maxlength);
			context.font='16px Courier New';
			context.fillStyle = "white";  
			var line = 0;
			while (line<(lines)){//while there are still lines of text to draw...
				context.fillText(message.slice(line*maxlength, (line+1)*(maxlength)),startx,(starty + line*24));
				line = line + 1;
				}//slice(startofline,endofline,startx,startyofline)
			}
		function targetchart(targets,xspace,yspace,x,y){
			context.font='12px Courier New';
			var sorttargets = [];//No sorting yet
			var i = 0 //assumes each column is same length, otherwise error
			while(i<targets.length){
				var cellposx = x;
				var cellposy = y+i*yspace;
				context.fillStyle = targets[i][0].c
				context.fillText(targets[i][0].name,cellposx,cellposy);
				var cellposx = x+xspace;
				context.fillText(targets[i][1],cellposx,cellposy);
				i=i+1;
				}
			context.fillStyle = "white";  
			}
		class Radio {
		constructor(intromessage){
			this.msgstart = 0; //Time that current message began
			this.sender = "Tutorial"; //Who sent the message
			this.senderx = 420;//Math.floor(canvas.width/2) - Math.floor(this.sender.length/2);//not used?
			this.sendery = Math.floor(canvas.height*5/6 - 50);
			this.msgnow = intromessage; //Text of message
			this.msgtime = Math.floor(this.msgnow.length*1.25) + 30; //message duration
			}
		newmsg(sndr, msg, thetime){//used to put a new message into the object
			this.msgstart = thetime;
			this.sender = sndr;
			this.senderx = Math.floor(canvas.width/2) - Math.floor(this.sender.length/2);
			this.msgnow = msg;
			this.msgtime = Math.floor(this.msgnow.length*1.5) + 120;
			}
		display(thetime){
			if (thetime<(this.msgstart+this.msgtime)){			
				context.font='16px Courier New';
				context.fillStyle = "red";  
				context.fillText(this.sender+":",this.senderx,this.sendery);
				showmessage(this.msgnow.slice(0, (thetime-this.msgstart) ));
				}
			}
		}////end class radio
		function drawaskey(xpos,ypos,keystring,keycolor){//seems to cause graphical glitches after a few minutes runtime
			context.font='16px Courier New';
			context.fillStyle = keycolor;  
			context.fillText(keystring,xpos,ypos);
			context.beginPath();//added after obsoleting the function due to a bug.  Maybe fixes it?
			context.strokeStyle = keycolor;
			context.rect(xpos-8,ypos-16,24,24);
			context.stroke();
			}
		function drawpolarpoly(px,py,thetalist, radiuslist, size, color, dir){
		//requires, does not verify, that thetalist.length==radiuslist.length, thetalist.length>2, color be valid
			var fx = px + Math.cos(dir+thetalist[0])*size*radiuslist[0];
			var fy = py + Math.sin(dir+thetalist[0])*size*radiuslist[0];
			context.fillStyle = color; //Now actual drawing of the things
			context.beginPath();
			context.moveTo(fx, fy); 
			i = thetalist.length;
			while(i>0){
				i=i-1;
				var ix = px + Math.cos(dir+thetalist[i])*size*radiuslist[i];
				var iy = py + Math.sin(dir+thetalist[i])*size*radiuslist[i];
				context.lineTo(ix, iy);
			}
			context.fill();	
		}
		function draworthopoly(px,py, xlist, ylist, size, color, dir){//Not really useful, because this
			var fx = px + xlist[0]*size; //needs to be transformed to polar coords to rotate it anyways
			var fy = py + ylist[0]*size;
			context.fillStyle = color; //Now actual drawing of the things
			context.beginPath();
			context.moveTo(fx, fy); 
			i = xlist.length;
			while(i>0){
				i=i-1;
				var ix = px + xlist[i]*size;
				var iy = py + ylist[i]*size;
				context.lineTo(ix, iy);
			}
			context.fill();	
			}
		function randpolarpoly(sides, minradius){//Polygons will be symmetrical, vertices evenly spaced
			spacing = 2*Math.PI/sides; //Needs at least 3.  Or 4, seems not to work right with odd numbers
			firstradius = Math.random()*(1-minradius) + minradius; //Minimum radius to make things less spiky
			vertices = [[0],[firstradius]];//Array of arrays, first element is list of angles, 2nd element is list of radii.
			i = 0;
			while (i<sides/2){ //First half is random
				i=i+1;
				vertices[0].push(spacing*i);
				vertices[1].push(Math.random()*(1-minradius) + minradius);
				}
			while (i<sides){ //2nd half matches first
				i=i+1;
				vertices[0].push(spacing*i);
				vertices[1].push(vertices[1][sides-i]);
				}
			return vertices; 
			}
		function normalizepoly(vertices){//Make the largest radii equal to 1, scale the others proportionally.
			var maxr = 0;
			i = vertices[1].length;
			while (i>0){//finds the largest radii
				i=i-1;
				if (vertices[1][i]>maxr){maxr = vertices[1][i];}
				}
			i = vertices[1].length;
			while (i>0){//Scales radii to 1
				i=i-1;
				vertices[1][i]=vertices[1][i]/maxr;
				}
			}
		function randvowel(){
			var vowels = "aeyuio";
			var vindex = Math.floor(Math.random()*vowels.length);
			return vowels[vindex];
			}
		function randconsonant(){
			var consonants = "zxcvbnmsdfghjklqwrtyp";
			var cindex = Math.floor(Math.random()*consonants.length);
			return consonants[cindex];
			}
		function randname(namelength){//Creates a random name of length namelength, with no more than 2 vowels or consonants in a row
			var lastchartype = Math.floor(Math.random()*2); //0 for consonant, 1 for vowel;
			var lastchartype2 = Math.floor(Math.random()*2); //2nd to last....
			var thischartype = Math.floor(Math.random()*2); //0 for consonant, 1 for vowel;
			var thename = ""; //Start with an empty name
			if (lastchartype2 == 0){thename=thename+randconsonant();}else{thename=thename+randvowel();}
			if (lastchartype == 0){thename=thename+randconsonant();}else{thename=thename+randvowel();}
			var i = namelength;
			while (i>2){
				i=i-1;
				if (lastchartype == lastchartype2){ //if last two characters are same type,
					if (lastchartype == 0){thischartype = 1;}else{thischartype = 0;} //make other type
					}else {thischartype = Math.floor(Math.random()*2);}//otherwise pick randomly
				if (thischartype == 0){thename=thename+randconsonant();}else{thename=thename+randvowel();}
				lastchartype2 = lastchartype; //Keep track of last two characters
				lastchartype = thischartype; //so we can not have 3 vowels or 3 consonants sequentially
				}
			return thename;
			}
		var testname = randname(8);
		function randcolor(){
			var thecolors = ["hotpink","deeppink","fuchsia","darkviolet","purple","indigo","salmon","crimson","red","darkred","orange","orangered","gold","yellow","khaki","lime","mediumspringgreen","seagreen","green","darkgreen","olive","teal","aqua","steelblue","lightskyblue","deepskyblue","blue","navy","tan","chocolate","sienna","maroon","silver","darkgrey","dimgrey"];
			return thecolors[Math.floor(Math.random()*thecolors.length)];
			}
		function drawmap(mplanets, mstations,scale,xx,yy, px, py){//scale of -1 indicates autozoom?  xx,yy are screen coords
					var i = mplanets.length; //px, py are perspective x and y
					var x = 0;
					var y = 0;
					var size = 1;
					var xzoombox = canvas.width/scale;
					var yzoombox = canvas.height/scale
					context.beginPath(); //rectangle centered on x,y
					context.rect(xx-xzoombox/2,yy-yzoombox/2, xzoombox, yzoombox); //2*this.s wide
					context.lineWidth = 1; 
					context.strokeStyle = "yellow";
					context.stroke();	
					while (i>0){
						i = i-1;
						x = xx + mplanets[i].x/scale - px/scale ;
						y = yy + mplanets[i].y/scale - py/scale;
						size = 1+ Math.floor(mplanets[i].s/scale);
						context.beginPath();
						context.strokeStyle = mplanets[i].c; //drawing planet
						context.arc(x, y, size, 0, 2 * Math.PI, false); 
						context.lineWidth = 1; 
						context.stroke();	//ok now actually draw it.	
						if (mplanets[i].parentid == 0){//If planet
							oradius = mplanets[0].distance(mplanets[i])/scale;
							context.beginPath();
							context.strokeStyle = "darkslategrey"; //drawing faint orbit radius
							context.arc(xx-px/scale, yy-py/scale, oradius, 0, 2 * Math.PI, false); 
							context.lineWidth = 1; 
							context.stroke();	//ok now actually draw it.	
							}
						}
					var i = mstations.length; //px, py are perspective x and y
					var x = 0;
					var y = 0;
					var size = 1;
					while (i>0){
						i = i-1;
						x = xx + mstations[i].x/scale - px/scale ;
						y = yy + mstations[i].y/scale - py/scale;
						size = 1+ Math.floor(mstations[i].s/scale);
						context.fillStyle = mstations[i].c; //drawing planet
						context.fillRect(x, y, 3, 3); 
						context.fill();
						}
					}
		//drawmap(planets,1000,canvas.width/2,200);//scale of -1 indicates autozoom?  xx,yy are screen coords
		function pointingat(objdir,dir,distance,size){ //are you pointing at a thing?
			var as = Math.atan2(size,distance); //how much angle does the thing occupy?
			var dd = dir - objdir; //How much off the actual direction are you pointing?
			while (dd > Math.PI){dd = dd - 2*Math.PI;} //This reduces the angle difference to within +- Math.PI
			while (dd < -1*Math.PI){dd = dd + 2*Math.PI;}
			while (as > Math.PI){as = as - 2*Math.PI;} //This reduces the angle difference to within +- Math.PI
			while (as < -1*Math.PI){as = as + 2*Math.PI;}
			if ((dd<as)&&(dd>-1*as)){//-1*anglesize < deltadir < anglesize
				return 1;
				}else {return 0;}
			}
		class Umo { //Universal Moving Object
		constructor(xxx, yyy, sss, ccc) {
			this.name = "Cactus Fantastico";
			this.type = "unspecified"; //I might use this to identify different
			this.x = xxx; //x
			this.y = yyy; //y
			this.c = ccc; //color
			this.s = sss; //size
			this.d = 0; // direction
			this.vx = 0; //start with 0 velocity 
			this.vy = 0;
			this.vd = 0; //0 rotation 
			this.m = this.s*this.s*this.s; //So far only used by gravitate function.
			this.thrust = 0;
			this.deadtime = 0;   //0 is alive.  N is dead for N more frames.
			this.hp = 100 ; //This is used for destructible entities to track health
			this.maxhp = 100;
			this.timer = 0; //Used for bombs.  Could maybe be consolidated with deadtime.
			this.hurt = 16 ; //used for bombs and planets.  Determines damage.
			this.boombuff = 0.5 ; // used for bombs.  Multiplies blast radius
			this.shield = 50; //for ships, mostly
			this.maxshield = 50; 
			this.shieldregen = 1;
			this.polyradius = [1,1,1]; //Default values are the triangle originally
			this.polytheta = [0,0.8*Math.PI,1.2*Math.PI];	//used for ship drawing
			this.level = 1; //Describes difficulty of a given ship
			this.parentid = 0;
			this.active = 1; //Flag indicating if ship (or planet's ships) needs to be considered by the game engine
			}
		update1(){ //Pure motion update.
			this.x = this.x + this.vx;
			this.y = this.y + this.vy;
			this.d = this.d + this.vd;
			}
		distance(relation){
			var dx = this.x - relation.x; 
			var dy = this.y - relation.y;
			return Math.sqrt(((dx)*(dx) + (dy)*(dy)));	
		}
		deltav(relation){ //returns magnitude only
			var dvx = this.vx - relation.vx; 
			var dvy = this.vy - relation.vy;
			return Math.sqrt(((dvx)*(dvx) + (dvy)*(dvy)));			
			}
		deltav2(relation){//returns magnitude, direction (polar vector)
			var dvx = this.vx - relation.vx; 
			var dvy = this.vy - relation.vy;
			var mag = Math.sqrt(((dvx)*(dvx) + (dvy)*(dvy)));	
			var dir =  -1*Math.atan2(dvx,dvy) - Math.PI/2;
			return [mag,dir];
			}
		match(that){  //This basically synchronizes two moving bodies
			this.x = that.x; //same position
			this.y = that.y;
			this.vx = that.vx;//same velocity
			this.vy = that.vy;
			this.d = that.d; //same direction
		}
		damage(dmg){ //Automatically applies damage to shield and hitpoints as appropriate
			if (this.shield > dmg){
				this.shield = this.shield - Math.floor(dmg);
			}else{
				this.hp = this.hp - Math.floor(dmg) + this.shield;
				this.shield = 0;
				}
			}
		collide(that){ //circular collision function
			if (this.distance(that) < (this.s + that.s)) {return true; }else{return false;} 
			} //Doesn't bounce or damage, just returns 1 if a collision is occuring.
		directionof(destination){
			var dx = this.x - destination.x; 
			var dy = this.y - destination.y;
			var	dirof = 0;	
			dirof = -1*Math.atan2(dx,dy) - Math.PI/2;//Sort of trial and error for this
			return dirof;	
			}
		track(target) { //Basic tracking algorithm.  Can be used to track any object compatible 
			var td = this.directionof(target); //with directionof, which just needs a .x and .y to work with
			var dd = this.directionof(target)-this.d;
			while (dd > Math.PI){dd = dd - 2*Math.PI;} //This reduces the angle difference to within +- Math.PI
			while (dd < -1*Math.PI){dd = dd + 2*Math.PI;} //which 
			if (dd > .04){ this.vd =+.03; }
			else if (dd < -0.04){ this.vd = -.03; }
			else {	this.vd = 0; }
			}
		gravitate(pulled){ //For planets.
			var dx = this.x - pulled.x; 
			var dy = this.y - pulled.y;
			var distance = Math.sqrt(((dx)*(dx) + (dy)*(dy)));
			var gconstant = 0.0003;
			var magnitude = (gconstant*this.m)/(distance*distance);
			var dcos = dx/distance;
			var dsin = dy/distance;
			pulled.vx = pulled.vx + magnitude*dcos;
			pulled.vy = pulled.vy + magnitude*dsin;
			}
		gravitategroup(pulled){ //Input is a list of objects to pull.  
			var i = pulled.length;
			var dx, dy, distance, gconstant, magnitude, dcos, dsin;
			while (i>0){ //Cycles through list of objects to be pulled
				i=i-1;
				dx = this.x - pulled[i].x; 
				dy = this.y - pulled[i].y;
				distance = Math.sqrt(((dx)*(dx) + (dy)*(dy)));
				gconstant = 0.0003;
				magnitude = (gconstant*this.m)/(distance*distance);
				dcos = dx/distance;
				dsin = dy/distance;
				pulled[i].vx = pulled[i].vx + magnitude*dcos;
				pulled[i].vy = pulled[i].vy + magnitude*dsin;
				}
			}	
		push(mag,dir){
			this.vx = this.vx + mag*Math.cos(dir);
			this.vy = this.vy + mag*Math.sin(dir);
		}
		circlecollide(that){ //circular bouncing
			var dir = this.directionof(that);
			var dvx = this.vx - that.vx;
			var dvy = this.vy - that.vy;
			var thedeltav = this.deltav2(that);
			var dvmag = thedeltav[0];
			var dvdir = thedeltav[1];
			var pushmag = Math.cos(dir - dvdir)*dvmag;
			if (this.distance(that) < (this.s + that.s)) {
				that.push(-2*pushmag, (this.directionof(that)));
				that.damage(this.hurt); 
				}
			}
		bombcollide(that){ //explodes on contact, damages every frame in explosion
			if (this.distance(that) < (this.s + that.s)) {
				that.damage(this.hurt); //Automatically proportional based on time spent inside 
				if (this.timer>6){this.timer = 6;}//sets off explosion by setting timer to start of explosion
				}
			}
		squarebouncecollide(that){
			var dx = this.x-that.x;
			var dy = this.y-that.y;
			if ((( dx<(this.s+that.s) )&&( dx>-1*(this.s+that.s) ))&&(( dy<(this.s+that.s) )&&( dy>-1*(this.s+that.s) ))) {
				//Checks if in x range AND in y range.  
				var dvx = this.vx - that.vx;
				var dvy = this.vy - that.vy;
				if (dx*dx > dy*dy){ //closer in Y than X, bounce off vertical wall.  Squared to make postive for comparison
					that.vx = that.vx + 2*dvx;//Adds double the X-axis difference to cancel and reverse the X velocity difference.
					that.damage(dvx); //damage proportional to closing velocity
					}
				if (dy*dy > dx*dx){ //closer in X than Y, bounce off horizontal wall
					that.vy = that.vy + 2*dvy;
					that.damage(dvy);
					}
				}
			}
		drawship(viewx, viewy){ //Ships are drawn as polar polygons, a triangle is the default.  Viewx/viewy are camera center
			var x = this.x - viewx + canvas.width/2; //normally camera center being the player ship.
			var y = this.y - viewy + canvas.height/2;
			drawpolarpoly(x,y,this.polytheta, this.polyradius, this.s, this.c, this.d);//ship polyon
			var shieldthick = Math.floor(this.shield*4/this.maxshield); //shield
			if (shieldthick>0){ //Needs to not render at all sometimes because linewidth of 0 is ignored instead of invisible.
				context.beginPath();  //So instead of not rendering, it will render at most recent thickness (often max)
				context.arc(x, y, this.s+2, 0, 2 * Math.PI, false); //until linewidth of 1 is reached.
				context.lineWidth = shieldthick;
				context.strokeStyle = "blue";
				context.stroke();	
			}//Now a health bar/////////////////////////////////////////
			var prop = this.hp / this.maxhp;
			var hpc = "green"; //health bar color depends on healthiness
			if (prop < 0.66){ hpc = "yellow"; }
			if (prop < 0.33){ hpc = "red"; }
			context.fillStyle = hpc; //health bar color depends on ship condition
            context.fillRect(x-this.s/2, y+this.s, Math.floor(this.s*prop), 4);
			}
		drawplanet(viewx, viewy){ //input variables are player ship/camera position
			var x = this.x - viewx + canvas.width/2; //this function draws object as a circle,
			var y = this.y - viewy + canvas.height/2; //and labels it
			context.beginPath();
			context.strokeStyle = this.c; //sets planet color
			context.arc(x, y, this.s, 0, 2 * Math.PI, false); //draws the circle
			context.lineWidth = 16; //circle is thicc
			context.stroke();	//ok now actually draw it.
			context.fillStyle = "white"; 
			context.font='20px Arial';
			context.fillText(this.name,x,y);		
		}
		drawbomb(viewx, viewy){ //Bombs are also drawn as circles, but not labelled.
			var x = this.x - viewx + canvas.width/2;
			var y = this.y - viewy + canvas.height/2;
			context.beginPath();
			context.strokeStyle = this.c;
			context.arc(x, y, this.s, 0, 2 * Math.PI, false);
			context.lineWidth = 4;
			context.stroke();		 
		}
		drawdot(viewx, viewy){ //Draws as a solid circle
			var x = this.x - viewx + canvas.width/2;
			var y = this.y - viewy + canvas.height/2;
			context.beginPath();
			context.strokeStyle = this.c;
			context.arc(x, y, this.s, 0, 2 * Math.PI, false);
			context.fillStyle = this.c;
			context.fill();
			context.lineWidth = 2;
			context.stroke();		 
		}
		drawstation(viewx, viewy){ //input variables are player ship position
			var x = this.x - viewx + canvas.width/2;//stations are squares for now
			var y = this.y - viewy + canvas.height/2;
			drawpolarpoly(x,y,this.polytheta, this.polyradius, this.s, this.c, this.d);//ship polyon
			context.fillStyle = "white";
			context.font='20px Arial';
			context.fillText(this.name,x,y);		
		}
		dock(dship){
			var offsetd = 0;
			var offsetr = 128;
			dship.match(this);
			dship.x = this.x+offsetr*Math.cos(this.d+offsetd);
			dship.y = this.y+offsetr*Math.sin(this.d+offsetd);
			dship.d = this.d;
			}
		undock(dship){
			var offsetd = 0;
			var offsetr = 200;
			dship.match(this);
			dship.x = this.x+offsetr*Math.cos(this.d+offsetd);
			dship.y = this.y+offsetr*Math.sin(this.d+offsetd);
			dship.d = this.d;
			dship.push(2,this.d);
			}
		drawreticle(viewx, viewy){ //input variables are player ship / camera position
			var x = this.x - viewx + canvas.width/2; //draws reticle around object
			var y = this.y - viewy + canvas.height/2; //circular reticle.
			context.beginPath();
			context.arc(x, y, this.s+24, 0, 2 * Math.PI, false);
			context.lineWidth = 2;
			context.strokeStyle = "white";
			context.stroke();	
		}
		drawcompass(targetship, compassx, compassy, compasssize){  //Draws a triangle pointing in direction of targetship
			var de = targetship.directionof(this); //targetship doesn't actually have to be a ship
			var tipx = Math.cos(de)*compasssize + compassx; //triangle points
			var tipy = Math.sin(de)*compasssize + compassy; //sort of from polar coordinates
			var taillx = Math.cos(de + 0.9*Math.PI)*compasssize + compassx;
			var tailly = Math.sin(de + 0.9*Math.PI)*compasssize + compassy;
			var tailrx = Math.cos(de + 1.1*Math.PI)*compasssize + compassx;
			var tailry = Math.sin(de + 1.1*Math.PI)*compasssize + compassy;
			context.fillStyle = this.c; //Now actual drawing of the things
			context.beginPath(); 
			context.moveTo(tipx, tipy); //Could be consolidated for less lines with above.
			context.lineTo(taillx, tailly);
			context.lineTo(tailrx, tailry);
			context.lineTo(tipx, tipy);
			context.fill();
			context.font='12px Arial';
			context.fillStyle = "white";
			//context.fillText(this.name,compassx-8,compassy - 48);
			context.fillText(this.name,compassx-8,compassy - compasssize);
			context.fillStyle = "white";
			//context.fillText(this.hp,compassx-8,compassy - 32);
			context.fillStyle = "white";
			context.fillText(Math.floor(this.distance(targetship)),compassx-16,compassy + compasssize);
			}// end compass stuff
			
		drawcompass2(targetship, compassx, compassy, compasssize){  //Draws a triangle pointing in direction of targetship
			var de = this.directionof(targetship); //targetship doesn't actually have to be a ship
			var tl = [0,0.05,0.4,-0.4,-0.05];
			var rl = [1,0.85,0.8,0.8,0.85];
			drawpolarpoly(compassx,compassy,tl, rl, compasssize, "yellow", de);//function drawpolarpoly(px,py,thetalist, radiuslist, size, color, dir){
			drawpolarpoly(compassx,compassy,targetship.polytheta, targetship.polyradius, compasssize*0.5, targetship.c, targetship.d);//function drawpolarpoly(px,py,thetalist, radiuslist, size, color, dir){
			context.font='12px Arial';
			context.fillStyle = "white";
			//context.fillText(this.name,compassx-8,compassy - 48);
			context.fillText(targetship.name,compassx-8,compassy - compasssize);
			context.fillStyle = "white";
			//context.fillText(this.hp,compassx-8,compassy - 32);
			context.fillStyle = "white";
			context.fillText(Math.floor(this.distance(targetship)),compassx-16,compassy + compasssize);
			}// end compass stuff
		updateship(theplanets){//Unfortunately I need access to the list of planets to handle ship respawning.
			if ((thruster > 0)&&(this.thrust > 0)){ //skips these calculations if no thrust
				this.vx = this.vx + this.thrust*Math.cos(this.d);
				this.vy = this.vy + this.thrust*Math.sin(this.d);
				thruster = thruster - this.thrust*12;
				}
			this.thrust = 0; //keeps thrusters momentary
			this.x = this.x + this.vx;
			this.y = this.y + this.vy;
			this.d = this.d + this.vd;
			if ((this.hp < 0) && (this.hp !==-1000)){ this.killship(1800); }
			this.deadtime = this.deadtime - 1;
			if (this.thruster > 100){ this.thruster = 100; }
			this.energy = this.energy + 1;
			if (this.energy > 100){	this.energy = 100; }				
			this.shield = this.shield + this.shieldregen;
			if (this.shield > this.maxshield){ this.shield = this.maxshield; }			
			if ((this.deadtime < 0) && (this.hp == -1000)){
				this.respawn(theplanets[this.parentid]); //maybe change how I handle this
				}
			}
			updatebomb(){ //Handles timer and explosions
			this.timer= this.timer -1;
			if (this.timer == 0){this.killbomb();}
			if (this.timer == 1){this.s = 100*this.boombuff;}
			if (this.timer == 2){this.s = 128*this.boombuff;}
			if (this.timer == 3){this.s = 120*this.boombuff;}
			if (this.timer == 4){this.s = 100*this.boombuff;}
			if (this.timer == 5){this.s = 75*this.boombuff;}
			if (this.timer == 6){this.s = 50*this.boombuff;}
			if (this.timer>6){
				this.s = 8; //Mostly redundant
				if (this.hp < 0){this.timer = 6;}
				}
			}
		killship(deathtime){ //Ship is dead, and respawns after deathtime frames.
			this.x = 1000000+ Math.random()*100000; //Dead ships are banished 
			this.y = 0;
			this.vx = 0;
			this.vy = 0;
			this.vd = 0;
			this.d = 0;
			this.deadtime = deathtime; //deadtime counts down to trigger respawn
			this.hp = -1000;
			}
		killbomb(){ 
			this.x = 1000000 + Math.random()*100000; //Dead ships are banished 
			this.y = 0;
			this.vx = 0;
			this.vy = 0;
			this.vd = 0;
			this.d = 0;
			this.s = 8;
			}
		setorbit(parentplanet, distance, direction, cw){ //cw = -1 or 1
			this.match(parentplanet); //set velocity and position equal
			this.x = this.x + (distance)*Math.cos(direction); //set relative
			this.y = this.y + (distance)*Math.sin(direction); //start location;
			var gravy = parentplanet.m*.0003 / (distance*distance);  //gMm/r^2, where m is 1;
			var orbitspeed = Math.sqrt(gravy*distance);  //a = v^2/r, a* r = v^2, v = sqrt(a*r)
			this.vx = this.vx + orbitspeed*Math.cos(direction + cw*Math.PI/2);
			this.vy = this.vy + orbitspeed*Math.sin(direction + cw*Math.PI/2);
			}
		respawn(parentplanet){
			var rdir = Math.random()*Math.PI*2; //random direction from planet
			var rdist = parentplanet.s+this.s+12+Math.random()*2*parentplanet.s; //random ish distance
			var rcw = Math.floor(Math.random()*2)*2 - 1; //random orbit direction (-1 or 1);
			this.setorbit(parentplanet, rdist, rdir, rcw);
			this.hp = this.maxhp;
			}
		launchbomb(thebomb, mag, time){ //This allows significant weapon customization in the function call. 
			thebomb.match(this);	// Mag is how hard the bomb is pushed, time is how long before the bomb detonates on it's own.
			thebomb.x = thebomb.x + (this.s+thebomb.s+4)*Math.cos(this.d);
			thebomb.y = thebomb.y + (this.s+thebomb.s+4)*Math.sin(this.d); 
			thebomb.timer = time;
			thebomb.hp = 1;
			thebomb.push(mag,this.d);
			}
		drawbeam(viewx, viewy, beamlength, beamwidth, beamcolor){  //Draws the lazor
			var x = this.x - viewx + canvas.width/2; //normally camera center being the player ship.
			var y = this.y - viewy + canvas.height/2;
			var beamstartx = x + (this.s+4)*Math.cos(this.d);
			var beamstarty = y + (this.s+4)*Math.sin(this.d); 
			var beamstopx = x + (this.s+4+beamlength)*Math.cos(this.d);
			var beamstopy = y + (this.s+4+beamlength)*Math.sin(this.d); 
			context.strokeStyle = beamcolor; //Now actual drawing of the things
			context.lineWidth = beamwidth;
			context.beginPath(); 
			context.moveTo(beamstartx, beamstarty); 
			context.lineTo(beamstopx, beamstopy);
			context.stroke();
		}
		beamcollide(beamlength, target){ //Returns 1 if the beam of length beamlength is touching target Umo.
		var collide = 0;
		if (this.distance(target) < (this.s+target.s+beamlength)){
			var deltad = this.d - this.directionof(target);
			if (deltad > Math.PI){deltad = deltad - 2*Math.PI;}
			if (deltad < -1*Math.PI){deltad = deltad + 2*Math.PI;}
			if ((deltad< Math.PI/2)&&(deltad>-1*Math.PI/2)){
				var m = Math.tan(this.d);
				var x1 = this.x;
				var y1 = this.y;
				var x2 = target.x;
				var y2 = target.y; 
				var dy =  m*(x2-x1)+y1-y2 
				var dist = Math.abs(dy/m);
				if (dist<target.s){
					collide = 1;
					}
				}
			}
		return collide;
		}
	}//end Umo class.//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
//////////////////////////////slashes because I want to see this spot easily//////////////////////////////////////////////////////////////////////////////////



//////Special bomb in development/////////////////////////////////////////////
class Clusterbranch{
	constructor(starttime,startx,starty,startvx,startvy,startdir,startsize,endsize,startcolor,maxlength,curl,decay){
		this.t=starttime;
		this.s = startsize;
		this.esize = endsize;
		this.c = startcolor;
		this.ml = maxlength;
		this.x = startx;
		this.y = starty; 
		this.vx = startvx;
		this.vy = startvy;
		this.decay = decay;
		this.curl = curl;
		this.d = startdir;
		this.branch = [new Umo(startx,starty,startsize,startcolor)];
		this.branch[0].vx = this.vx;
		this.branch[0].vy = this.vy;
		var i=0;
		while (i<maxlength){
			i=i+1;
			this.s = this.s*this.decay;
			this.d = this.d + this.curl;
			this.x = this.x+this.s*Math.cos(this.d);
			this.y = this.y+this.s*Math.sin(this.d);
			if (this.c == "red"){this.c = "orange";}
			else if (this.c == "orange"){this.c = "yellow";}
			else if (this.c == "yellow"){this.c = "green";}
			else if (this.c == "green"){this.c = "blue";}
			else if (this.c == "blue"){this.c = "purple";}
			else if (this.c == "purple"){this.c = "red";}
			this.branch.push(new Umo(this.x,this.y,this.s,this.c));
			this.branch[this.branch.length-1].vx = this.vx;
			this.branch[this.branch.length-1].vy = this.vy;
			}
		}
	draw(viewx,viewy,thetime){
		var dt = thetime-this.t;
		if (dt<this.branch.length){var i=dt;}
		else{var i=this.branch.length;}
		while(i>0){
			i=i-1;
			this.branch[i].drawdot(viewx,viewy);
			}
		}
	update1(){ //Pure motion update.
		var i=this.branch.length;
		while (i>0){
			i=i-1;
			this.branch[i].update1();
			if (this.branch[i].c == "red"){this.branch[i].c = "purple";}
			else if (this.branch[i].c == "purple"){this.branch[i].c = "blue";}
			else if (this.branch[i].c == "blue"){this.branch[i].c = "green";}
			else if (this.branch[i].c == "green"){this.branch[i].c = "yellow";}
			else if (this.branch[i].c == "yellow"){this.branch[i].c = "orange";}
			else if (this.branch[i].c == "orange"){this.branch[i].c = "red";}
			}
		}
	}
let testbranch = new Clusterbranch(0,500,500,4,4,1,42,12,"red",12,0.1,0.95);
class Clusterbomb{
	constructor(starttime,startx,starty,startvx,startvy,startn,branchmod,startsize,decay,startcolor,maxlength,curl){
		this.t=starttime;
		this.s = startsize;
		this.c = startcolor;
		this.ml = maxlength;
		this.x = startx;
		this.y = starty; 
		this.vx = startvx;
		this.vy = startvy;
		this.decay =decay;
		this.curl = curl;
		var branchspacing = 2*Math.PI/startn;
		var stage1branches = [];
		var i=0;
		while (i<startn){
			stage1branches.push(new Clusterbranch(this.t,this.x,this.y,this.vx,this.vy,i*branchspacing,this.s,0,this.c,branchmod,this.curl*(Math.random()*2-1),this.decay));
			i=i+1;
			}	
		var i=0;
		var stage2branches = [];
		while (i<stage1branches.length){
			stage2branches.push(new Clusterbranch(stage1branches[i].t+branchmod,stage1branches[i].x,stage1branches[i].y,stage1branches[i].vx,stage1branches[i].vy,stage1branches[i].d,stage1branches[i].s,0,stage1branches[i].c,branchmod,this.curl*(Math.random()*2-1),this.decay));
			stage2branches.push(new Clusterbranch(stage1branches[i].t+branchmod,stage1branches[i].x,stage1branches[i].y,stage1branches[i].vx,stage1branches[i].vy,stage1branches[i].d,stage1branches[i].s,0,stage1branches[i].c,branchmod,stage1branches[i].curl,this.decay));
			i=i+1
			}
		var i=0;
		var stage3branches = [];
		while (i<stage2branches.length){
			stage3branches.push(new Clusterbranch(stage2branches[i].t+branchmod,stage2branches[i].x,stage2branches[i].y,stage2branches[i].vx,stage2branches[i].vy,stage2branches[i].d,stage2branches[i].s,0,stage2branches[i].c,branchmod,this.curl*(Math.random()*2-1),this.decay));
			stage3branches.push(new Clusterbranch(stage2branches[i].t+branchmod,stage2branches[i].x,stage2branches[i].y,stage2branches[i].vx,stage2branches[i].vy,stage2branches[i].d,stage2branches[i].s,0,stage2branches[i].c,branchmod,stage2branches[i].curl,this.decay));
			i=i+1
			}		
		this.s1b = stage1branches;
		this.s2b = stage2branches;
		this.s3b = stage3branches;
		}
	draw(viewx,viewy, thetime){
		var i=0;
		while (i<this.s3b.length){
			this.s3b[i].draw(viewx,viewy,thetime)
			i=i+1;
			}
		var i=0;
		while (i<this.s2b.length){
			this.s2b[i].draw(viewx,viewy,thetime)
			i=i+1;
			}
		var i=0;
		while (i<this.s1b.length){
			this.s1b[i].draw(viewx,viewy,thetime)
			i=i+1;
			}
		
		}
	update1(){ //Pure motion update.
		var i=this.s1b.length;
		while (i>0){
			i=i-1;
			this.s1b[i].update1();
			}
		var i=this.s2b.length;
		while (i>0){
			i=i-1;
			this.s2b[i].update1();
			}		
		var i=this.s3b.length;
		while (i>0){
			i=i-1;
			this.s3b[i].update1();
			}		
		}
	}	
var testcluster = new Clusterbomb(0,100,100,2,2,5,8,48,0.95,"red",233,0.3);
//let testcluster = new Clusterbomb(0,ships[0].x+100,ships[0].y,ships[0].vx,ships[0].vy,5,8,48,0.95,"red",233,0.3);


/////////////////////////////Begin system class///////////////////////////////////////////////////////////////////////////////////////////////////////////////
class System{
	constructor(index, name, x, y){
	this.index = index; //integer identifying system 
	this.name = name; //name of system for display
	this.planets = []; //list of planets (to be generated)
	this.ships = []; //list of ships (to be generated)
	this.botbombs = []; //list of bombs used in system
	this.difficulty = 1; //Scales ship generation attributes
	}
	randomplanets(){
		var numplanets = Math.floor(Math.random()*16+2);//random number of planets, 2-17
		var orbitradius = 0; //randomized in the loop
		var planetsize = 0; //randomized in the loop
		this.planets.push( new Umo(0,0,Math.floor(Math.random()*3000+1000), "orange") ); //make the sun 
		this.planets[0].name = this.name; // Star name is same as system name
		var i=0;
		while (i<numplanets-1){
			i=i+1; //planets[0] is already the sun, so we can skip index 0;
			orbitradius = Math.floor( (Math.random()*Math.random()*250000) + 2000); //Minimum radius 2000, 1/r density factor
			planetsize = Math.floor( Math.random()*Math.random()*800 + Math.random()*100+100 ); //Minimum size 100, 
			this.planets.push( new Umo(0,0,planetsize, randcolor() ) );//this is where the planet gets added to the array
			this.planets[i].name = randname(4);//random 4 character name
			this.planets[i].setorbit(this.planets[0], orbitradius, Math.random()*6.28, 1);
			this.planets[i].parentid = 0; //establishes star (planet[0] as parent planet
			//this.randommoons(i);
			}
		}
	randommoons(index){//index is of planet
		var nummoons = Math.floor(Math.random()*planets[index].s/150 )//Planets < 150 in size have 0 chance of a moon, planet 300 in size has 50% chance of 1 moon, etc.
		var moonsize = 0; //randomized in loop
		var moonorbitr = 0;//randomized in loop
		var moonindex = 0; //set in loop
		i = nummoons;
		while (i>0){
			i=i-1;
			moonsize = Math.floor(Math.random()*this.planets[index].s/3+10);//radius is 10 plus up to 1/3 of parent planet
			moonorbitr = Math.floor(this.planets[index].s*(Math.random()*3+1.5)); //orbit radius is 1.5x parent planet radius + up to 3x parent planet radius
			moonindex = this.planets.length-1;
			this.planets.push( new Umo(0,0,moonsize, randcolor()) );
			this.planets[moonindex].name = randname(4);
			this.planets[moonindex].parentid = index;
			this.planets[moonindex].setorbit(this.planets[index],moonorbitr,Math.random()*6.28, 1);//orbit direction is 1, not random
			}
		}
	levelup(botindex,levels){//adds "levels" to make bots tougher
		var i = levels;
		while(i>0){
			i=i-1;
			var bonus = Math.floor(Math.random()*5);//Picks a number to select which bonus the bot gets
			if (bonus==0){ //extra health
				this.ships[botindex].maxhp = this.ships[botindex].maxhp+100;
				this.ships[botindex].hp = this.ships[botindex].hp+100;
				}
			if (bonus==1){ //extra shield
				this.ships[botindex].maxshield = this.ships[botindex].maxshield+50;
				ships[botindex].shield = ships[botindex].shield+50;
				}
			if (bonus==2){ //extra shield regen
				ships[botindex].shieldregen = ships[botindex].shieldregen+0.25;
				}			
			if (bonus==3){ //extra bomb damage
				botbombs[botindex-1].hurt = botbombs[botindex-1].hurt+8;
				}						
			if (bonus==4){ //extra bomb blast
				botbombs[botindex-1].boombuff = botbombs[botindex-1].boombuff+0.25;//I think botbombs needs -1 because it does not include a bomb for ships[0] (player)
				}			
			ships[botindex].level = ships[botindex].level+1;
			}
		}
	addrandomgang(planetindex, num,level){ //Adds a gang of enemy ships, level describes difficulty (not used yet)
		var gangsize = num;
		var gangcolor = randcolor();
		var gangparent = planetindex;
		var randomsides = Math.floor(Math.random()*8)*2+8; //randomized side number
		var randomplayerverts = randpolarpoly(randomsides, 0.25);//sides,  minimum radius
		normalizepoly(randomplayerverts);
		var gangpolytheta = randomplayerverts[0];
		var gangpolyradius = randomplayerverts[1];
		
		var i = gangsize;
		while (i>0){
			i=i-1;
			this.ships.push(new Umo(-600,32000,32,gangcolor));
			var botindex = this.ships.length-1;
			this.ships[botindex].parentid = gangparent; 
			this.ships[botindex].respawn(this.planets[this.ships[botindex].parentid]);
			this.ships[botindex].name = randname(5);
			this.ships[botindex].hp = 150;
			this.ships[botindex].maxhp = 150;
			this.ships[botindex].polytheta = gangpolytheta;
			this.ships[botindex].polyradius = gangpolyradius;
			this.botbombs.push( new Umo(0,0,0,"red"));
			this.levelup(botindex,level);
			}
		}
	}//end of system class////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Mission{
	constructor(missiontype, morigin, mtarget,mmessage,mreward,mstory){
		this.type = missiontype; //string indicating type of mission, such as "Assassinate", "Defend" or "Cargo"
		this.origin = morigin; //Starting point for a cargo mission, in positive integer planet index
		this.target = mtarget; //Target for mission, positive integer list for ship(s) or planet index.
		this.message = mmessage; //"Kill that guy", "Take cargo to that planet"
		this.reward = mreward; //How much money you get, 0 indicates mission no longer active
		this.storypath = mstory; //What storystate the mission leads to, 0 for no affect on storystate
		}
	check(theships,theplanets,theradio){ //Determines if mission is complete
		var complete = 0;
		if (this.type == "assassinate"){ //If the mission is to kill a guy
			if (theships[this.target].hp < 0){complete = 1;} //If the ship is dead, the mission is complete.  Doesnt work yet
			}
			
		else if (this.type == "cargo"){ //If the mission is to take cargo to a planet.  Works on last test.
			if ((theplanets[this.target].distance(ships[0])<500) && (theplanets[this.target].deltav(ships[0])<10)){
				complete = 1; //Requires that you get close, and get slow relative to target planet.
				}
			}
		else if (this.type == "courier"){ //If the mission is to take cargo to a ship.  Untested
			if ((theships[this.target].distance(theships[0])<500) && (theships[this.target].deltav(theships[0])<10)){
				complete = 1; //Requires that you get close, and get slow relative to target planet.
				}
			}
		if (complete == 1){
			playerradio.newmsg("Dudeman",this.type+" mission complete.  Keep doing my thing. Payment of "+this.reward+" has been deposited.",time);//newmsg(sndr, msg, thetime)
			var givenreward = this.reward; //Saves mission reward to be returned
			var givenstory = this.storypath;
			this.type = ""; //Resets to inactive values.
			this.origin = 0;
			this.target = 0;
			this.message = "No mission";
			this.reward = 0;
			this.storypath = 0;
			return [givenreward,givenstory];//Storypath will be 0 for non-story missions, nonzero values will set the story state of the player in main loop
			}
			else {return [0,0];}
		}
	}
	//////////////////Function tests
	let testsystem = new System(2,"thetestsystem");
	testsystem.randomplanets();
	let playerradio = new Radio(" ");
	let mission1 =  new Mission("cargo", 0, 11, "Deliver this cheesy burrito to a client on Mede.",500, 1);
	let mission2 =  new Mission("assassinate", 0, 6, "A nasty robot in earf orbit needs to be removed.",1500, 0);
	//constructor(missiontype, morigin, mtarget,mmessage,mreward)
////////Declarations//////////////////////////////////////////////////////////////////////////////////
////////This is basically the game world/////////////////////////////////////////////////////////////////
////////Player stuff///////////////////////////////////////////////////////////
////////Planets////////////////////////////////////////////////////////////////////////////////////////
function loadhomesystem(){
	let sun = new Umo(0, 0, 2048, "orange"); //planet initialization/////////////
	sun.name = "Sool";
	let murc = new Umo(0,8000,150,"brown");//initial position irrelevant
	murc.name = "Murc";
	murc.setorbit(sun, 8000, 0, 1);
	murc.parentid = 0;
	let vnus = new Umo(0,14000,280,"yellow");//2
	vnus.name = "Vnus";
	vnus.setorbit(sun, 14000, 0, 1);
	vnus.parentid = 0;
	let earf = new Umo(0, 20000, 320, "blue"); //3
	earf.setorbit(sun, 20000, 0, 1);
	earf.name = "Earf";
	earf.parentid = 0;
	let moon = new Umo(1000, 20000, 100, "white"); //4
	moon.name = "Moon";
	moon.setorbit(earf, 1000, 0, 1);
	moon.parentid = 3;
	let merz = new Umo(0, 32000, 220, "red");//5
	merz.name = "Merz";						
	merz.setorbit(sun, 32000, 0, 1);
	merz.parentid = 0;
	let fobz = new Umo(600,32000,32, "white");//6
	fobz.name = "Fobz";
	fobz.setorbit(merz, 600, 0, 1);
	fobz.parentid = 5;
	let deem = new Umo(-800,32000,32, "white");//7
	deem.name = "Deem";
	deem.setorbit(merz, 800, 0, 1);
	deem.parentid = 5;
	let jupe = new Umo(0,0,1024,"brown");//8
	jupe.name = "Jupe";
	jupe.setorbit(sun,80000,0,1);
	jupe.parentid = 0;
	let heyo = new Umo(0,0,120,"yellow");//9
	heyo.name = "Heyo";
	heyo.setorbit(jupe,1280,0,1);
	heyo.parentid = 8;
	let erpa = new Umo(0,0,200,"blue");//10
	erpa.name = "Erpa";
	erpa.setorbit(jupe,3600,0,1);
	erpa.parentid = 8;
	let mede = new Umo(0,0,280,"brown");//11
	mede.name = "Mede";
	mede.setorbit(jupe,5200,0,1);
	mede.parentid = 8;
	let isto = new Umo(0,0,280,"tan");//12
	isto.name = "Isto";
	isto.setorbit(jupe,7200,0,1);
	isto.parentid = 8;
	let tern = new Umo(0,0,750,"yellow");//13
	tern.name = "Tern";
	tern.setorbit(sun,130000,0,1);
	tern.parentid = 0;
	let thys  = new Umo(0,0,120,"grey");//14
	thys.name = "Thys";
	thys.setorbit(tern,1200,0,1);
	thys.parentid = 13;
	let dion  = new Umo(0,0,150,"grey");//15
	dion.name = "Dion";
	dion.setorbit(tern,1800,0,1);
	dion.parentid = 13;
	let raya  = new Umo(0,0,200,"grey");//16
	raya.name = "Raya";
	raya.setorbit(tern,2400,0,1);
	raya.parentid = 13;
	let itan  = new Umo(0,0,300,"grey");//17
	itan.name = "Itan";
	itan.setorbit(tern,3600,0,1);
	itan.parentid = 13;
	let peet  = new Umo(0,0,200,"grey");//18
	peet.name = "Peet";
	peet.setorbit(tern,5600,0,1);
	peet.parentid = 13;
	let anus = new Umo(0,0,500,"green");//19
	anus.name = "Anus";
	anus.setorbit(sun,170000,0,1);
	anus.parentid = 0;
	let aril  = new Umo(0,0,150,"grey");//20
	aril.name = "Aril";
	aril.setorbit(anus,1000,0,1);
	aril.parentid = 19;		
	let umbi  = new Umo(0,0,150,"grey");//21
	umbi.name = "Umbi";
	umbi.setorbit(anus,1500,0,1);
	umbi.parentid = 19;				
	let titi  = new Umo(0,0,200,"grey");//22
	titi.name = "Titi";
	titi.setorbit(anus,2400,0,1);
	titi.parentid = 19;			
	let bron  = new Umo(0,0,200,"grey");//23
	bron.name = "Bron";
	bron.setorbit(anus,3000,0,1);
	bron.parentid = 19;		
	let tune = new Umo(0,0,550,"cyan");//24
	tune.name = "Tune";
	tune.setorbit(sun,210000,0,1);
	tune.parentid = 0;
	let tron = new Umo(0,0,250,"cyan");//25
	tron.name = "Tron";
	tron.setorbit(tune,1500,0,1);
	tron.parentid = 24;
	let homeplanets = [sun,murc,vnus,earf,moon,merz,fobz,deem,jupe,heyo,erpa,mede,isto,tern,thys,dion,raya,itan,peet,anus,aril,umbi,titi,bron,tune,tron];
	return homeplanets;
	}
let planets = loadhomesystem();
	//let planets = testsystem.planets; //basically works, but not ready.
////////Initialize Player//////////////////////////////////////////////////////////
let testship = new Umo (0,0,32,"black");//Used for calculations
let player1 = new Umo(400,32400,32,randcolor());//player ship
player1.hp = 1000; //1000 health,
player1.maxhp = 1000;//1000 maximum health
player1.parentid = 3; //Spawn relative to planet index 3.
player1.maxshield = 200; //Shield strength can be modified per ship
player1.shield = 200;
randomsides = Math.floor(Math.random()*8)*2+8; //randomized side number
randomplayerverts = randpolarpoly(randomsides, 0.25);//sides,  minimum radius
normalizepoly(randomplayerverts); //Makes the ship have at least 2 vertices at maximum radius (1).
player1.polytheta = randomplayerverts[0];//Assigns randomized polygon
player1.polyradius = randomplayerverts[1]; //to player1 ship
player1.setorbit(planets[0], 32000, 0.3, 1); 
var ships = [player1];
///////Special Station Umos//////////////////////////////////////////////////////////////////////////////
let terranoutpost = new Umo (0,0,128, randcolor());
terranoutpost.parentid = 0;
terranoutpost.name = "Bill's Billion Bits";
var totheta = [Math.PI/4,3*Math.PI/4,5*Math.PI/4,7*Math.PI/4];
var toradii = [1,1,1,1]; //rectangle
terranoutpost.polytheta = totheta;
terranoutpost.polyradius = toradii;
terranoutpost.setorbit(planets[0], 20000, 0.25, 1);//set in orbit around sun behind earf 

let merzoutpost = new Umo(0,0,128, randcolor());
merzoutpost.parentid = 0;
merzoutpost.name = "The Merry Merzian";
var totheta = [Math.PI/4,3*Math.PI/4,5*Math.PI/4,7*Math.PI/4];
var toradii = [1,1,1,1]; //rectangle
merzoutpost.polytheta = totheta;
merzoutpost.polyradius = toradii;
merzoutpost.setorbit(planets[0], 32000, 0.2, 1);//set in orbit around sun behind merz

let jupeoutpost = new Umo(0,0,128, randcolor());
jupeoutpost.parentid = 0;
jupeoutpost.name = "Jojo's House of Cheese";
var totheta = [Math.PI/4,3*Math.PI/4,5*Math.PI/4,7*Math.PI/4];
var toradii = [1,1,1,1]; //rectangle
jupeoutpost.polytheta = totheta;
jupeoutpost.polyradius = toradii;
jupeoutpost.setorbit(planets[0], 80000, 0.1, 1);//set in orbit around sun behind jupe

let anusoutpost = new Umo(0,0,128, randcolor());
anusoutpost.parentid = 0;
anusoutpost.name = "Dangustown";
var totheta = [Math.PI/4,3*Math.PI/4,5*Math.PI/4,7*Math.PI/4];
var toradii = [1,1,1,1]; //rectangle
anusoutpost.polytheta = totheta;
anusoutpost.polyradius = toradii;
anusoutpost.setorbit(planets[0], 170000, 0.05, 1);//set in orbit around sun behind jupe

let outposts = [terranoutpost, merzoutpost, jupeoutpost, anusoutpost];
////////Player Bombs//////////////////////////////////////////////////////////////////////////////////////////       
function loadplayerbombs(){
	let p1b1 = new Umo(0,0,8,"red"); //Player weapon 1
	p1b1.c = "red"; //Staple player weapon
	p1b1.hurt = 16;
	p1b1.boombuff = 0.75;
	let p1b2 = new Umo(0,0,0,0); //Player weapon 2
	p1b2.c = "purple"; //Slow, powerful bomb
	p1b2.boombuff = 1.5;
	p1b2.hurt  = 64;
	let p1b3 = new Umo(0,0,0,0);  //Player weapon 3
	p1b3.c = "green"; //Weak short range flak weapon.		
	p1b3.boombuff = 1.2;
	p1b3.hurt = 12;
	let p1b4 = new Umo(0,0,0,0); //Player weapon 4
	p1b4.c = "blue"; //Fast, powerful, but costly projectile with minimal blast.		
	p1b4.boombuff = 0.2;
	p1b4.hurt = 50;
	let p1b50 = new Umo(0,0,0,0);//Weapon 5 will have 4 projectiles
	p1b50.c = "blue"; 		
	p1b50.boombuff = 0.5;
	p1b50.hurt = 12;
	let p1b51 = new Umo(0,0,0,0);
	p1b51.c = "blue"; 		
	p1b51.boombuff = 0.5;
	p1b51.hurt = 12;
	let p1b52 = new Umo(0,0,0,0);
	p1b52.c = "blue"; 		
	p1b52.boombuff = 0.5;
	p1b52.hurt = 12;
	let p1b53 = new Umo(0,0,0,0);
	p1b53.c = "blue"; 		
	p1b53.boombuff = 0.5;
	p1b53.hurt = 12;
	let p1b70 = new Umo(0,0,0,0);
	p1b70.c = "red"; 		
	p1b70.boombuff = 0.25;
	p1b70.hurt = 10;
	let p1b71 = new Umo(0,0,0,0);
	p1b71.c = "orange"; 		
	p1b71.boombuff = 0.25;
	p1b71.hurt = 10;
	let p1b72 = new Umo(0,0,0,0);
	p1b72.c = "yellow"; 		
	p1b72.boombuff = 0.25;
	p1b72.hurt = 10;
	let p1b73 = new Umo(0,0,0,0);
	p1b73.c = "green"; 		
	p1b73.boombuff = 0.25;
	p1b73.hurt = 10;
	let p1b74 = new Umo(0,0,0,0);
	p1b74.c = "blue"; 		
	p1b74.boombuff = 0.25;
	p1b74.hurt = 10;
	let p1b75 = new Umo(0,0,0,0);
	p1b75.c = "purple"; 		
	p1b75.boombuff = 0.25;
	p1b75.hurt = 10;
	let p1b76 = new Umo(0,0,0,0);
	p1b76.c = "purple"; 		
	p1b76.boombuff = 0.25;
	p1b76.hurt = 10;
	let p1b77 = new Umo(0,0,0,0);
	p1b77.c = "blue"; 		
	p1b77.boombuff = 0.25;
	p1b77.hurt = 10;
	let p1b78 = new Umo(0,0,0,0);
	p1b78.c = "green"; 		
	p1b78.boombuff = 0.25;
	p1b78.hurt = 10;
	let p1b79 = new Umo(0,0,0,0);
	p1b79.c = "yellow"; 		
	p1b79.boombuff = 0.25;
	p1b79.hurt = 10;
	let p1b710 = new Umo(0,0,0,0);
	p1b710.c = "orange"; 		
	p1b710.boombuff = 0.25;
	p1b77.hurt = 10;
	let p1b711 = new Umo(0,0,0,0);
	p1b711.c = "red"; 		
	p1b711.boombuff = 0.25;
	p1b711.hurt = 10;
	let p1b80 = new Umo(0,0,0,0);//weapon 8 is a chain-fired blaster
	p1b80.c = "red"; 		
	p1b80.boombuff = 0.25;
	p1b80.hurt = 10;	
	let p1b81 = new Umo(0,0,0,0);
	p1b81.c = "orange"; 		
	p1b81.boombuff = 0.25;
	p1b81.hurt = 10;	
	let p1b82 = new Umo(0,0,0,0);
	p1b82.c = "yellow"; 		
	p1b82.boombuff = 0.25;
	p1b82.hurt = 10;	
	let p1b83 = new Umo(0,0,0,0);
	p1b83.c = "green"; 		
	p1b83.boombuff = 0.25;
	p1b83.hurt = 10;	
	let p1b84 = new Umo(0,0,0,0);
	p1b84.c = "blue"; 		
	p1b84.boombuff = 0.25;
	p1b84.hurt = 10;	
	let p1b85 = new Umo(0,0,0,0);
	p1b85.c = "purple"; 		
	p1b85.boombuff = 0.25;
	p1b85.hurt = 10;	
	let p1b9 = new Umo(0,0,0,0);
	p1b9.c = "purple"; 		
	p1b9.boombuff = 2;
	p1b9.hurt = 20;	
	let p1b10 = new Umo(0,0,0,0);
	p1b10.c = "purple"; 		
	p1b10.boombuff = 0;
	p1b10.hurt = 1;	
	let pbs = [p1b1,p1b2,p1b3,p1b4,p1b50,p1b51,p1b52,p1b53,p1b70,p1b71,p1b72,p1b73,p1b74,p1b75,p1b76,p1b77,p1b78,p1b79,p1b710,p1b711,p1b80,p1b81,p1b82,p1b83,p1b84,p1b85,p1b9,p1b10]; 
	return pbs;
	}
let playerbombs = loadplayerbombs();
var i = playerbombs.length;
while (i>0){  //For all player bombs, set them up as a bomb Umos.
	i=i-1;
	playerbombs[i].hp = 1;  //Set hitpoints to 1 so they explode on contact
	playerbombs[i].maxhp = 1; //with planets 
	playerbombs[i].shield=0;  
	} 
let home = new System(1,"Sool");
let botbombs=[];
home.planets = planets;
home.ships = ships;
home.botbombs = botbombs;
//////procedural bot ship generation//////////////////////////////////////////////////////////////////////////////////////////////////
home.addrandomgang(1,2,24);
home.addrandomgang(2,3,3);
home.addrandomgang(3,3,2);//no moon bots
home.addrandomgang(5,3,1);//no deem, fobz, jupe, or heyo bots
home.addrandomgang(10,3,4);
home.addrandomgang(11,4,6);
home.addrandomgang(12,3,5);
home.addrandomgang(14,2,7);
home.addrandomgang(15,4,9);
home.addrandomgang(16,4,10);
home.addrandomgang(17,4,8);
home.addrandomgang(18,2,11);
home.addrandomgang(21,2,6);
home.addrandomgang(22,2,6);
home.addrandomgang(23,4,4);//no tune bots
home.addrandomgang(25,5,16);
var i = home.botbombs.length;
while (i>0){  ////For all bot bombs, set them up as a bomb Umos.
	i=i-1;
	home.botbombs[i].hp = 1;  //Set hitpoints to 1 so they explode on contact
	home.botbombs[i].maxhp = 1; //with planets 
	home.botbombs[i].shield=0;  
	}
////////////////GAME LOOP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////update function this is the game loop bruh///////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function update() {
	time = time + 1;
	context.fillStyle = "black";//Background is black
	context.fillRect(0, 0, canvas.width, canvas.height); //rectangle the size of the canvas.
	if (mapactive == 1){drawmap(planets,outposts,mapscale,canvas.width/2,canvas.height/2, ships[0].x, ships[0].y);}//centered map
	if (mapactive == 2){drawmap(planets,outposts,mapscale,200,canvas.height-150,ships[0].x, ships[0].y);
		context.fillStyle = "black";//Background is black
		context.fillRect(0, 0, canvas.width, canvas.height-300); //erase non-corner map area
		context.fillRect(400, canvas.height-300, canvas.width,canvas.height); //erase non-corner map area
		context.beginPath(); //Border of map rectangle
		context.rect(0,canvas.height-300,400,300); //2*this.s wide
		context.lineWidth = 4; 
		context.strokeStyle = "blue";
		context.stroke();	
		}
//Outpost stuff all handled here.....
		var i=0;
		while (i<outposts.length){
			planets[0].gravitate(outposts[i]);
			outposts[i].d = outposts[i].directionof(planets[0]);
			outposts[i].update1();
			if (ships[0].distance(outposts[i])<drawdistance+outposts[i].s/2){ //if ships[i] is near
				outposts[i].drawstation(ships[0].x,ships[0].y); //draw station from ship[0]'s view
			if (ships[0].distance(outposts[i])<160){
				outposts[i].dock(ships[0]);
				dockstate = i+1;
				}		
			}
			i=i+1;
			}

/////////////////Determine which planets are close enough to be "active", and activate relevant ships///////////////////////////////////////////////////
			var i = planets.length;
			while (i>0){//For all planets...
				i=i-1;
				var adist = ships[0].distance(planets[i]);
				if ((planets[i].active==1)&&(adist>20000)){//If planet is already active and far away 
					planets[i].active = 0; //deactivate
				}else if ((planets[i].active==0)&&(adist<10000)){//else if planet is inactive and close
					planets[i].active = 1; //activate
					}	
				}
///////////////////Drawing/////////////////////////////////////////////////////////////////////////////////////
			var i=ships.length; //draw ships and planets///////////////////////////////////
			while (i>0){ //for all ships,
				i=i-1;
				if (ships[0].distance(ships[i])<drawdistance+ships[i].s/2){ //if ships[i] is near
					ships[i].drawship(ships[0].x,ships[0].y); //draw ship from ship[0]'s view
					}
				}
			i = planets.length; 
			while (i>0){ //for all planets
				i=i-1;
				if (ships[0].distance(planets[i])<drawdistance+planets[i].s/2){ //if planets[i] is near
					planets[i].drawplanet(ships[0].x,ships[0].y); //draw planet from shop[0]'s view
					}
				}
			i = botbombs.length; //for all bot bombs
			while (i>0){
				i=i-1;
				if (ships[0].distance(botbombs[i])<drawdistance){ // if bombs[i] is near
					botbombs[i].drawbomb(ships[0].x,ships[0].y); //draw bomb from ship[0]'s view
					}
				}	
			i = playerbombs.length; //for all player bombs
			while (i>0){
				i=i-1;
				if (ships[0].distance(playerbombs[i])<drawdistance){ // if bombs[i] is near
					playerbombs[i].drawbomb(ships[0].x,ships[0].y); //draw bomb from ship[0]'s view
					}
				}					
			i = ships.length; //update section////////////////////////////////////////////////////////////
			while (i>0){ //update ships
				i=i-1;
				ships[i].updateship(planets);
				}
			i = planets.length; //update planets
			while (i>0){
				i=i-1;
				planets[i].update1();
				}
			i = botbombs.length; //update bot bombs
			while (i>0){
				i=i-1;
				botbombs[i].update1();
				botbombs[i].updatebomb();
				}	
			i = playerbombs.length; //update player bombs
			while (i>0){
				i=i-1;
				playerbombs[i].update1();
				playerbombs[i].updatebomb();
				}	
			if (thruster<100){thruster=thruster+1;} //External variable updates
			if (energy<100){energy = energy +1;}
			i=planets.length; //gravitate section////////////////////////////////////////////////////
			while (i>0){ //Planet on ships and bombs
				i=i-1;
				var j = ships.length;
				while (j>0){ //gravitate on each ship
					j=j-1;
					planets[i].gravitate(ships[j]);
					}
				j = botbombs.length;
				while (j>0){ //gravitate on each bot bomb
					j=j-1;
					planets[i].gravitate(botbombs[j]);
					}  
				j = playerbombs.length;
				while (j>0){ //gravitate on each player bomb
					j=j-1;
					planets[i].gravitate(playerbombs[j]);
					}  
				}
			var i = planets.length;
			while (i>1){//Planet on planet gravity
				i=i-1;
				planets[0].gravitate(planets[i]);//sun gravitates all
				if (planets[i].parentid>0){	planets[planets[i].parentid].gravitate(planets[i]); } //others only affected by parent
				}
////////////collisions/////////////////////////////////////////////////////
			var i = planets.length;
			var j = ships.length;
			var k = playerbombs.length;
			while (i>0){ //For all planets (and bombs and ships)
				i=i-1;
				j = ships.length;
				while (j>0){ //For all ships to each planet
					j=j-1;
					planets[i].circlecollide(ships[j]);
					}
				k = playerbombs.length;
				while (k>0){ //For all bombs to each planet
					k=k-1;
					planets[i].circlecollide(playerbombs[k]); 
					}
				k = botbombs.length;
				while (k>0){ //For all bombs to each planet
					k=k-1; 
					planets[i].circlecollide(botbombs[k]);
					}
				}
			j = ships.length;
			k = playerbombs.length;
			while (j>0){ //for all ships (and bombs)
				j=j-1;
				k = playerbombs.length;
				while (k>0){
					k=k-1;
					if (ships[j].hp>=0){//do not execute on dead ships.  Maybe check player distance too.
						playerbombs[k].bombcollide(ships[j]);
						if (ships[j].hp<0){
							var getcash = Math.floor(Math.random()*21+10)*ships[j].level;
							money = money + getcash;
							gotmoney = [30,getcash];
							}//Doesn't handle death, just cash.
						}
					}	
				k = botbombs.length;
				while (k>0){
					k=k-1;
					if (ships[j].hp>=0){//do not execute on dead ships.  Maybe check player distance too.
						botbombs[k].bombcollide(ships[j]);
						if (ships[j].hp<0){
							var getcash = Math.floor(Math.random()*21+10);
							//money = money + getcash;//disabled bot kill payouts for now
							//gotmoney = [30,getcash];
							}//Doesn't handle death, just cash.
						}
					}	
				}
////////////AI behavior section///////////////////////////////////////////////
			var j = ships.length; 
			while (j>1){ //Does not act on ship[0], which is player1.  This means botbomb length is 1 less than ships.  Index must be adjusted accordingly
				j=j-1; 
				if ( (  ships[j].distance(planets[ships[j].parentid]) > 6000  )&&(ships[j].hp>0) ){//If this bot got lost....
					var savedhp = ships[j].hp; //remember it's hitpoints... 
					ships[j].respawn(planets[ships[j].parentid]); //Respawn...
					ships[j].hp = savedhp; //re-apply hitpoints so it doesn't get a free heal out of it.
					}
				if (ships[0].distance(ships[j]) < 5000){ //Don't do anything if player is far
					ships[j].track(ships[0]); //Bots point towards player
					if ((Math.random()>0.96) && (botbombs[j-1].timer < 1)){  //Bots fire occasionally, if bomb isn't out
						var howclose = ships[j].distance(planets[ships[j].parentid])-(ships[j].s+planets[ships[j].parentid].s);
						var lookat =  pointingat(ships[j].directionof(planets[ships[j].parentid]),ships[j].d,ships[j].distance(planets[ships[j].parentid]),ships[j].parentid.s);
						//		function pointingat(objdir,dir,distance,size){ //are you pointing at a thing?
						//if ((howclose>500)||(lookat==0)){}
						ships[j].launchbomb(botbombs[j-1], 12, 80); 					
						}
					}
				}
///////Respawn handling////////////////////////////////////////////////////////////////////////////////////////////
			j = ships.length;
			while (j>0){
				j = j - 1;
				if ((ships[j].deadtime < 0) && (ships[j].hp == -1000)){ //Death is handled in the update1
					ships[j].respawn(planets[ships[j].parentid]); 
					}
				}
//////////Mouse turning/////////////////////////////////
			ships[0].d = moused+Math.PI; //Instant turning because its easy for now
//HUD information/////////////////////////////////////////////////////////////////////////////////////
//pointingat test///pointingat(objdir,dir,distance,size)
		var pointingtest = pointingat(ships[0].directionof(planets[3]), ships[0].d, ships[0].distance(planets[3]),planets[3].s)
///////////////Targeting HUD////////////////////////////////////////////////////////////////////////////////////////////////
			context.font='12px Arial';
			context.fillStyle = "white"; 
			var shipsinrange = [];//To help guide what ships are targetable by the player, I'm generating a short list / shallow copy of nearby ships.
			//var radarrange = 5000;//Defines distance a ship can be from the player and still be targetable
			var closestdistance = 999999;//needs to be larger than radarrange 
			var closestindex = 0; //defaults to self-targeting if no ships in range
			var i=0;//Excludes player ship
			while (i<ships.length-1){ //this loop makes the short list
				i=i+1;
				var tdistance = Math.floor(ships[0].distance(ships[i]));
				if (tdistance<radarrange){shipsinrange.push([ships[i],tdistance,i]);}//shallow-copy ship into shipsinrange, with global index for reference [theship,distance,index]
				}
			var i=0;
			while (i<shipsinrange.length){//this loop finds the closest ship
				if (shipsinrange[i][1]<closestdistance){
					closestdistance = shipsinrange[i][1];//tracks closest distance,
					//closestindex = shipsinrange[i][2]; //and the global index (as in ships[index]) of the closest ship
					closestindex = i;					
					}
				i=i+1;
				}
			if (nmeactive == 1){//if targeting computer is on...
				var i=0;
				var nmechartnames = [];
				var nmechartdistances = [];
				while (i<shipsinrange.length){
					var shipname = shipsinrange[i][0].name;
					var shipdistance = shipsinrange[i][1];
					nmechartnames.push(shipname);
					nmechartdistances.push(shipdistance);
					i=i+1;
					}
				var nmechart1 = [nmechartnames,nmechartdistances];//maybe sort this by distance some day.
				//var cxytest = [ ["first", "column", "of", "words"], ["2nd", "column", "of", "words"]       ];
				targetchart(shipsinrange,64,16,canvas.width-300,16);
				//showchart(nmechart1, 64, 16, canvas.width-300,10);//test location
				if (shipsinrange.length == 0){
					context.font = '20px Ariel';
					context.fillStyle = "red";
					context.fillText("No targets in range", canvas.width-160, 24);
					}
				}
			if (shiptarget>shipsinrange.length-1){shiptarget = 0;}
			if (shipsinrange.length>0){
				//shipsinrange[shiptarget][0].drawcompass(ships[0],canvas.width-64, 96, 64); //Targeting computer compass
				ships[0].drawcompass2(shipsinrange[shiptarget][0],canvas.width-64, 96, 64); //Targeting computer compass
				shipsinrange[shiptarget][0].drawreticle(ships[0].x,ships[0].y); //Targeting reticle
				var nmechart2 = [["Name","Level","HP","Shield","Damage","Blast","Regen"],[shipsinrange[shiptarget][0].name, shipsinrange[shiptarget][0].level, shipsinrange[shiptarget][0].hp,  shipsinrange[shiptarget][0].shield,  botbombs[shipsinrange[shiptarget][2]-1].hurt, botbombs[shipsinrange[shiptarget][2]-1].boombuff,shipsinrange[shiptarget][0].shieldregen]];
				showchart(nmechart2, 64, 16, canvas.width-128,192);//test location
				context.beginPath(); 
				context.rect(canvas.width-304,4+16*shiptarget, 160, 16); //This is the item selection indicator
				context.lineWidth = 2; 
				context.strokeStyle = "white";
				context.stroke();	
				}
			//targetchart(shipsinrange,64,16,canvas.width-200,700);
			//maybe causeing the graphical problems?
			//drawaskey(canvas.width-324,32,"[","white");
			//drawaskey(canvas.width-324,64,"]","white");
			//drawaskey(canvas.width-324,96,"T","white");
			//drawaskey(32,canvas.height-320,"+","white");
			//drawaskey(64,canvas.height-320,"-","white");
			//drawaskey(96,canvas.height-320,"M","white");
			//drawaskey(canvas.width-32,canvas.height-200,">","white");
			//drawaskey(canvas.width-64,canvas.height-200,"<","white");
		
			
			
			//drawaskey(canvas.width-96,canvas.height-200,"N","white");
///////////////Navigation hud///////////////////////////////////////////////////////////////////////////////////////////////////////////
		if (navactive > 0){
			var thenavtarget=0;
			if (navactive==1){thenavtarget=planets[navtarget];}
			if (navactive==2){thenavtarget=outposts[navtarget];}
			thenavtarget.drawcompass(ships[0],canvas.width-64,canvas.height-96, 64); //Nav computer compass for planets
			var solardistance = planets[0].distance(ships[0]); //distance to sun
			var solargravity = (.0003*planets[0].m)/(solardistance*solardistance); //Gravitational influence of sun, pixels per frame per frame.
			var distance = thenavtarget.distance(ships[0]); //distance to target planet
			var planetarygravity = (.0003*thenavtarget.m)/(distance*distance); //gravity from target planet

			var name = thenavtarget.name;
			var pclass = "Moon"; //Defaults to Moon,
			if (navtarget==0){pclass = "Star";} //0 index is the sun
			else if (thenavtarget.parentid == 0){pclass = "Planet";}//Objects orbiting sun are planets
			var size = String(Math.floor(thenavtarget.s));
			var mass = String(Math.floor(thenavtarget.m/1000));
			var parent = planets[thenavtarget.parentid].name;	
			var orbitradius = thenavtarget.distance(planets[thenavtarget.parentid]);
			var orbitspeed = thenavtarget.deltav(planets[thenavtarget.parentid]);
			var orbitpos = planets[thenavtarget.parentid].directionof(thenavtarget);
			while (orbitpos > Math.PI){orbitpos=orbitpos - 2*Math.PI;} //This reduces the angle difference to within +- Math.PI
			while (orbitpos < -1*Math.PI){orbitpos = orbitpos + 2*Math.PI;}
			var distance = thenavtarget.distance(ships[0]); //distance to target planet
			//var planetarygravity = (.0003*planets[navtarget].m)/(distance*distance); //gravity from target planet
			var gravity = ((.0003*thenavtarget.m*900)/(distance*distance)).toFixed(3);
			var dv = thenavtarget.deltav2(ships[0]);
			var deltav = (dv[0]).toFixed(3).padStart(8,"0");
			var cosdv =  Math.cos(dv[1]-ships[0].directionof(thenavtarget))*dv[0];
			var sindv =  Math.sin(dv[1]-ships[0].directionof(thenavtarget))*dv[0];
			var escape = Math.sqrt(thenavtarget.m*2*.0003/ships[0].distance(thenavtarget));
			var navchart2 = [ ["Name","Class", "Size", "Mass", "Parent", "Orbit Radius", "Orbit speed", "Orbit Position"], [name, pclass, size, mass, parent, Math.floor(orbitradius), Math.floor(orbitspeed), orbitpos.toFixed(3)],  ["Distance","DeltaV", "Cos DV", "Sin DV", "Gravity", "Escape","X","Y"], [Math.floor(distance),deltav, cosdv.toFixed(3), sindv.toFixed(3), gravity, escape.toFixed(3),Math.floor(planets[navtarget].x), Math.floor(planets[navtarget].y)]  ];
			showchart(navchart2, 80, 16, canvas.width-480,canvas.height-160);	
			}
			context.fillText("Press N key to cycle navigation computer mode",canvas.width-300,canvas.height-8);
////////////////////////Map/////////////////////////////////////
			//if (mapactive == 1){drawmap(planets,256,canvas.width/2,canvas.height/2, ships[0].x, ships[0].y);}
			//planets[0].drawcompass(ships[0],canvas.width/2,canvas.height-48); //Nav computer compass for sun
///////////////Rest of HUD/////////////////////////////////////////////////////////////////////////////////////////////////	
	context.font='12px Arial';
	context.fillStyle = "orange"; //thruster power bar 
    context.fillRect(4, 64,Math.floor(0.64*thruster), 16);
	context.fillStyle = "red"; //weapons energy bar
    context.fillRect(4, 44,Math.floor(0.64*energy), 16);
	context.fillStyle = "blue"; //shield bar
    context.fillRect(4, 24,Math.floor(64*ships[0].shield/ships[0].maxshield), 16);
	context.fillStyle = "green"; //health bar
    context.fillRect(4, 4,Math.floor(64*ships[0].hp/ships[0].maxhp), 16);
	context.fillStyle = "white";
	var statuschart1 = [ ["Health","Shields", "Weapons", "Thrusters"]  ];
	showchart(statuschart1, 80, 20, 8,16);	
	context.fillText("Money",5,90);
	context.fillText(money,50,90);
	if (gotmoney[0]>0){
		gotmoney[0] = gotmoney[0]-1;
		context.fillStyle = "green";
		context.fillText("+"+gotmoney[1],100,90);
		context.fillStyle = "white";
		}
	context.fillText("Active Weapon:",8,110);
	context.fillText(wep,32,144);
	context.fillText("Mouse aims, left-flick fires, right-click thrusts, 1234567890 selects weapons. M toggles map mode, N toggles nav computer mode, < and > cycles nav targets, [ and ] cycles enemy targets, T for closest target (sometimes)",128,10);

	if (ships[0].hp==-1000){
	context.fillStyle = "red";
	context.font='24px Arial';
	context.fillText("u ded bruh."+ships[0].deadtime,canvas.width/2,canvas.height/2);
	context.fillStyle = "white";
	context.font='12px Arial';
	}
	context.fillStyle = "white";
	context.font='12px Arial';
	//context.fillText(mousestate,5,250);//tests and stuff
	//context.fillText(storystate,5,500);//tests and stuff
	playerradio.display(time);
////Shopping!//////////////////////////////////////////////////////
if (dockstate==1){//Earf station
	context.fillText("Up and Down to select, Enter to purchase.",canvas.width/2+64,canvas.height/2-120);
	var shopchart1 = [ ["$20 Repair hull", "$200 w3 Flakker", "$600 w1 Blaster Upgrade I (detonator)","$1000 w3 Flakker Upgrade I (damage)","$1000 w6 Laser","$800 Single-use extra hull","EMPTY","EMPTY","EMPTY","EMPTY"]  ];
	context.font='12px Arial';
	context.fillStyle = "white";
	showchart(shopchart1, 80,20,canvas.width/2+64, canvas.height/2-90);	
	context.fillText(shopitem,canvas.width/2+64,canvas.height/2+120);	
	context.beginPath(); 
	context.rect(canvas.width/2+60,canvas.height/2-104+20*shopitem, 256, 18); //This is the item selection indicator
	context.lineWidth = 2; 
	context.strokeStyle = "green";
	context.stroke();	
	}
if (dockstate==2){//Merz station
	context.fillText("Up and Down to select, Enter to purchase.",canvas.width/2+64,canvas.height/2-120);
	var shopchart1 = [ ["$20 Repair hull","$400 w2 Mine", "$200 w3 Flakker", "$600 w1 Blaster Upgrade I (detonator)","$1000 Armor Upgrade I","$3000 Radar Upgrade I","$400 Single-use extra hull","EMPTY","EMPTY","EMPTY"]  ];
	context.font='12px Arial';
	context.fillStyle = "white";
	showchart(shopchart1, 80,20,canvas.width/2+64, canvas.height/2-90);	
	context.fillText(shopitem,canvas.width/2+64,canvas.height/2+120);	
	context.beginPath(); 
	context.rect(canvas.width/2+60,canvas.height/2-104+20*shopitem, 256, 18); //This is the item selection indicator
	context.lineWidth = 2; 
	context.strokeStyle = "green";
	context.stroke();	
	}
if (dockstate==3){//Jupe station
	context.fillText("Up and Down to select, Enter to purchase.",canvas.width/2+64,canvas.height/2-120);
	var shopchart1 = [ ["$20 Repair hull","$400 w2 Mine", "$200 w3 Flakker", "$1000 w4 Railgun","$600 w1 Blaster Upgrade I (detonator)","$1200 w2 Mine Upgrade I (detonator)","$1000 w3 Flakker Upgrade I (damage)","$1000 Armor Upgrade I","$2000 Shield Upgrade I","$800 Single-use extra hull"]  ];
	context.font='12px Arial';
	context.fillStyle = "white";
	showchart(shopchart1, 80,20,canvas.width/2+64, canvas.height/2-90);	
	context.fillText(shopitem,canvas.width/2+64,canvas.height/2+120);	
	context.beginPath(); 
	context.rect(canvas.width/2+60,canvas.height/2-104+20*shopitem, 256, 18); //This is the item selection indicator
	context.lineWidth = 2; 
	context.strokeStyle = "green";
	context.stroke();	
	}
if (dockstate==4){//Anus station
	context.fillText("Up and Down to select, Enter to purchase.",canvas.width/2+64,canvas.height/2-120);
	var shopchart1 = [ ["$20 Repair hull","$1000 w4 Railgun","$2400 w5 SpreadShot Cannon","$4000 w6 Lazzor","$6000 w7 Double Rainbow","$4000 w8 Spectral Disintegrator", "$10000 w9 Bapadoop","$2000 Shield Upgrade I","$400 Single-use extra hull","EMPTY"]  ];
	context.font='12px Arial';
	context.fillStyle = "white";
	showchart(shopchart1, 80,20,canvas.width/2+64, canvas.height/2-90);	
	context.fillText(shopitem,canvas.width/2+64,canvas.height/2+120);	
	context.beginPath(); 
	context.rect(canvas.width/2+60,canvas.height/2-104+20*shopitem, 256, 18); //This is the item selection indicator
	context.lineWidth = 2; 
	context.strokeStyle = "green";
	context.stroke();	
	}
//////////////////////////////////Weapon 8 in-loop code, its special like that////////////////////////////////////////////////////////////////////////////////////
//Now here i'm kludging rapid fire with 6 w8 bombs.  It worked.
if((mousestate==1)&&(time%4==0)&&(wep==8)&&(energy>6)){
	var n = Math.floor(time/4)%6;
	ships[0].launchbomb(playerbombs[20+n],16,16);//A mere 1 pixel per frame, but for 600 frames (20s).
	energy = energy - 6;
	}
///////weapon 10 in-loop code, probe is special//////////////////////////////////////////////////
if (wep==0){//wep == 11 to disable, wep should ==0
	var j = ships.length;
	while (j>1){ //for all ships...
		j=j-1;
		if (playerbombs[27].collide(ships[j]));//Checks for collision only
			ships[0].polytheta = ships[j].polytheta;//Applies enemy polygon to player
			ships[0].polyradius = ships[j].polyradius;
			}
		}
//////crapware bomb testing goes here
		testcluster.update1();	
		testcluster.draw(ships[0].x,ships[0].y,time);
		
//////////////////////Story and Time Triggered Events//////////////////////////////////////////////////////////////////////
var dstory = time - storytime;
switch(storystate){//Tutorial missions so far.
	case 0:
		if (dstory==10){
			playerradio.newmsg("Tutorial Dude",storymessages[0],time);//newmsg(sndr, msg, thetime)
			}
		if (dstory == 600){
			playerradio.newmsg("Tutorial Dude",storymessages[1],time);//newmsg(sndr, msg, thetime)
			}
		if ((dstory>930)&&(navtarget==5)&&(navactive==1)){
			storystate = 1;
			storytime = time;
			}
		break;
	case 1:
		if (dstory==15){
			playerradio.newmsg("Tutorial Dude",storymessages[2],time);//newmsg(sndr, msg, thetime)
			}
		if (dstory == 600){
			playerradio.newmsg("Tutorial Dude",storymessages[3],time);//newmsg(sndr, msg, thetime)
			}
		if ((dstory>630)&&(mapscale>1024)&&(mapactive>0)){
			storystate=2;
			storytime = time;
			}
	break;
	case 2:
		if (dstory==15){
			playerradio.newmsg("Tutorial Dude",storymessages[4],time);//newmsg(sndr, msg, thetime)
			}
		if ((dstory>60)&&(mapscale<128)&&(mapactive>0)){
			storystate=3;
			storytime = time;
			}
	break;
	case 3:
		if (dstory==15){
			playerradio.newmsg("Tutorial Dude",storymessages[5],time);//newmsg(sndr, msg, thetime)
			}
		if ((dstory>60)&&(ships[0].distance(planets[5])<512)){
			storystate=4;
			storytime = time;
			}
	break;
	case 4:
		if (dstory==15){
			playerradio.newmsg("Tutorial Dude",storymessages[6],time);//newmsg(sndr, msg, thetime)
			}
		if ((dstory>60)&&(dockstate==2)){
			storystate=5;
			storytime = time;
			}
	break;
		case 5:
		if (dstory==playerradio.msgtime){//Doesn't work as-is, totalmsgtime was ill-conceived.  I'll probably have to either brute-force hardcode the msg timing, or advance storystate with each message.
			playerradio.newmsg("Tutorial Dude",storymessages[7],time);//newmsg(sndr, msg, thetime)
			storystate = 6;
			storytime = time;
			}
	break;
	case 6:
		if (dstory==playerradio.msgtime){//Doesn't work as-is, totalmsgtime was ill-conceived.  I'll probably have to either brute-force hardcode the msg timing, or advance storystate with each message.
			playerradio.newmsg("Tutorial Dude",storymessages[8],time);//newmsg(sndr, msg, thetime)
			storystate = 7;
			storytime = time;
			}
	break;		
	case 7:
		if (dstory==playerradio.msgtime){//Doesn't work as-is, totalmsgtime was ill-conceived.  I'll probably have to either brute-force hardcode the msg timing, or advance storystate with each message.
			playerradio.newmsg("Tutorial Dude",storymessages[9],time);//newmsg(sndr, msg, thetime)
			storystate = 8;
			storytime = time;
			}
	break;		
	case 8:
		if (dstory==playerradio.msgtime){//Doesn't work as-is, totalmsgtime was ill-conceived.  I'll probably have to either brute-force hardcode the msg timing, or advance storystate with each message.
			playerradio.newmsg("Tutorial Dude",storymessages[10],time);//newmsg(sndr, msg, thetime)
			storystate = 9;
			storytime = time;
			}
	break;		
	case 9:
		if (dstory==playerradio.msgtime){
			playerradio.newmsg("Tutorial Dude",storymessages[11],time);//newmsg(sndr, msg, thetime)
			storystate = 10;
			storytime = time;
			}
	break;		
	case 10:
		if (dstory==playerradio.msgtime){
			playerradio.newmsg("Tutorial Dude",storymessages[12],time);//newmsg(sndr, msg, thetime)
			storystate = 11;
			storytime = time;
			}
	break;		
	case 11:
		if (dstory==playerradio.msgtime){
			playerradio.newmsg("Tutorial Dude",storymessages[13],time);//newmsg(sndr, msg, thetime)
			storystate = 12;
			storytime = time;
			}
	break;	
	case 12:
		if (dstory==playerradio.msgtime){
			playerradio.newmsg("Tutorial Dude",storymessages[14],time);//newmsg(sndr, msg, thetime)
			storystate = 13;
			storytime = time;
			}
	break;			
	case 13:
		if (dstory==playerradio.msgtime){
			playerradio.newmsg("Tutorial Dude",storymessages[15],time);//newmsg(sndr, msg, thetime)
			storystate = 14;
			storytime = time;
			}
	break;		
	case 14:
		if (dstory==playerradio.msgtime){
			playerradio.newmsg("Tutorial Dude",storymessages[16]+ships[9].name,time);//newmsg(sndr, msg, thetime)
			ships[9].respawn(planets[ships[9].parentid]);
			storystate = 15;
			storytime = time;
			}
	break;	

	case 15:
		if ((dstory>playerradio.msgtime)&&(ships[9].hp==-1000)){
			playerradio.newmsg("Tutorial Dude",storymessages[17],time);//newmsg(sndr, msg, thetime)
			storystate = 16;
			storytime = time;
			}
	break;		
	case 16:
		if ((dstory>playerradio.msgtime)&&(dockstate==2)){
			playerradio.newmsg("Tutorial Dude",storymessages[18],time);//newmsg(sndr, msg, thetime)
			storystate = 17;
			storytime = time;
			}
	break;
	case 17:
		if (dstory>playerradio.msgtime){
			playerradio.newmsg("Tutorial Dude",storymessages[19],time);//newmsg(sndr, msg, thetime)
			storystate = 18;
			storytime = time;
			}
	break;	
	case 18:
		if (dstory==playerradio.msgtime){
			playerradio.newmsg("Tutorial Dude",storymessages[20],time);//newmsg(sndr, msg, thetime)
			w2=1;
			storystate = 19;
			storytime = time;
			}
	break;	
	case 19:
		if ((wep==2) && (playerbombs[1].s>32)){//If w2 has fired and exploded
			playerradio.newmsg("Tutorial Dude",storymessages[21],time);//newmsg(sndr, msg, thetime)
			wep=1;
			w2=0;
			storystate = 20;
			storytime = time;
			}
	break;	
	case 20:
		if (dockstate==2){//if player has retuirned to the merry merz
			playerradio.newmsg("Tutorial Dude",storymessages[22],time);//newmsg(sndr, msg, thetime)
			w2=1;
			storystate = 21;
			storytime = time;
			}
	break;	
	}
//if (time==300){
//playerradio.newmsg("Dudeman",mission1.message,time);//newmsg(sndr, msg, thetime)
//}

//Mission checks///////////////////////////////////////////////////////////////////
var completemission1 = mission1.check(ships,planets,playerradio); //Saves mission reward money to variable if mission is completed, check function also modifies storystate
money = money + completemission1[0];
if (completemission1[1]>0){storystate=completemission1[1];}
//
////////////////////////////////////////////////////////Keyboard input/////////////////////////////////////
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return; // Do nothing if the event was already processed
  }
  switch (event.key) {  //events for all the keyboard keys
    case " ":
      ships[0].thrust = 2*thrustmultiplier; //pushes player in direction this.d
      break;   
	case "z": //sort of a secret feature, might become an upgrade later
		if (thrustmultiplier < 2){ thrustmultiplier = thrustmultiplier + .25; }
		else { thrustmultiplier = 0.25; }
      break;
	case "a": //Not really used
		if (launchmultiplier < 2){ launchmultiplier = launchmultiplier + .25; }
		else {	launchmultiplier = 0; }
      break;	  
	case "1":    //This is how weapon switching is handled.
		if (w1>0){ wep = 1; } //If weapon is present, switch to it.		
		break; //Nothing happens on keypress otherwise.
	case "2": 
		if (w2>0){ wep = 2; }
	  break;
	case "3": 
		if (w3>0){ wep = 3; }
      	break;
	case "4": 
		if (w4>0){ wep = 4; }
   	 break;
	case "5": 
		if (w5>0){ wep = 5; }
	  break;
	case "6": 
		if (w6>0){ wep = 6; }
   	   break;
	case "7": 
		if (w7>0){ wep = 7; }
	  break;
	case "8": 
		if (w8>0){ wep = 8; }
 	     break;
	case "9": 
		if (w9>0){ wep = 9; }
	  break;
	case "0": 
		if (w0>0){ wep = 0; }
     	 break;
	case "n": 
		if (navactive == 0){
			navactive = 1;
			if (navtarget>planets.length-1){navtarget=0;}
		} else if (navactive == 1) {
			navactive = 2;
			if (navtarget > outposts.length-1){navtarget=0;}
		} else if (navactive == 2){navactive = 0;}
    	  break;
	case "m": 
		if (mapactive == 0){mapactive = 2;} else {mapactive = mapactive-1;}
    	  break;
	case "+": 
		mapscale = mapscale * 0.9;
		if (mapscale>64){mapscale = Math.floor(mapscale);}
    	  break;		  
	case "-": 
		mapscale = mapscale * 1.1;
		if (mapscale>64){mapscale = Math.floor(mapscale);}
    	  break;	  
	case ".": 
			if (navactive == 1){
				navtarget = navtarget+1;
				if (navtarget == planets.length){ navtarget = 0; }
			}else if (navactive == 2){
				navtarget = navtarget+1;
				if (navtarget == outposts.length){navtarget = 0; }
				}
    	  break;
	case ",": 
		if (navactive == 1){
			navtarget = navtarget-1;
			if (navtarget == -1){ navtarget = planets.length-1; }
		}else if (navactive == 2){
			navtarget = navtarget-1;
			if (navtarget == -1){ navtarget = outposts.length-1; }
			}
		break;		  
	case "w": 
		ships[0].respawn(planets[navtarget]);
     	 break;
	case "]": 
		if (shiptarget == shipsinrange.length-1){ shiptarget = 0; }
		else {shiptarget = shiptarget+1;}	                                          
      break;
	case "[": 
		if (shiptarget == 0){ shiptarget = shipsinrange.length-1; }
		else {shiptarget = shiptarget-1;}	                                          
      break;
	case "t": 
		shiptarget = closestindex;                                         
      break;
    case "ArrowUp":
		shopitem = shopitem - 1;
		if (shopitem<0){shopitem = 9;}
      break;
    case "ArrowDown":
		shopitem = shopitem + 1;
		if (shopitem>9){shopitem = 0;}
      break;   //handled in detail elsewhere
    case "End":
		w1 = 2;
		w2 = 2;
		w3 = 2;
		w4 = 1;
		w5 = 1;
		w6 = 1;
		w7 = 1;
		w8 = 1;
		w9 = 1;
		w0 = 1;
		money = money +10000;
      break;   //handled in detail elsewhere

    case "x":
		var clustercolor = "red";
		//if (time%6==0){clustercolor="red";}
		////if (time%6==1){clustercolor="orange";}
		//if (time%6==2){clustercolor="yellow";}
		//if (time%6==3){clustercolor="green";}
		//if (time%6==4){clustercolor="blue";}
		//if (time%6==5){clustercolor="purple";}

		testcluster = new Clusterbomb(time,ships[0].x+mdx,ships[0].y+mdy,ships[0].vx,ships[0].vy,12,16,32,0.95,clustercolor,233,0.3);
      break;   //handled in detail elsewhere
	case "s":
		var tbx = ships[0].x+100;
		var tby = ships[0].y+100;
		var curlr1 = Math.random()-0.5;
		var curlr2 = Math.random()-0.5;
		var curlr3 = Math.random()-0.5;
		var curlr4= Math.random()-0.5;
		var curlr5 = Math.random()-0.5;
		var curlr6 = Math.random()-0.5;
		var dirr1 = Math.random()*2*Math.PI;
		var dirr2 = Math.random()*2*Math.PI;
		var dirr3 = Math.random()*2*Math.PI;
		testbranch2 = new Clusterbranch(time,tbx,tby,ships[0].vx,ships[0].vy,dirr1,48,12,"red",16,curlr1,0.95);
		testbranch3 = new Clusterbranch(time,tbx,tby,ships[0].vx,ships[0].vy,dirr2,48,12,"red",20,curlr2,0.95);
		testbranch4 = new Clusterbranch(time,tbx,tby,ships[0].vx,ships[0].vy,dirr3,48,12,"red",24,curlr3,0.95);
		
		testbranch5 = new Clusterbranch(time+16,testbranch2.x,testbranch2.y,ships[0].vx,ships[0].vy,testbranch2.d,testbranch2.s,24,testbranch2.c,24,curlr1,0.95);
		testbranch6 = new Clusterbranch(time+20,testbranch3.x,testbranch3.y,ships[0].vx,ships[0].vy,testbranch3.d,testbranch3.s,20,testbranch3.c,20,curlr2,0.95);
		testbranch7 = new Clusterbranch(time+24,testbranch4.x,testbranch4.y,ships[0].vx,ships[0].vy,testbranch4.d,testbranch4.s,8,testbranch4.c,16,curlr3,0.95);
		testbranch8 = new Clusterbranch(time+16,testbranch2.x,testbranch2.y,ships[0].vx,ships[0].vy,testbranch2.d,testbranch2.s,12,testbranch2.c,24,curlr4,0.95);
		testbranch9 = new Clusterbranch(time+20,testbranch3.x,testbranch3.y,ships[0].vx,ships[0].vy,testbranch3.d,testbranch3.s,10,testbranch3.c,20,curlr5,0.95);
		testbranch10 = new Clusterbranch(time+24,testbranch4.x,testbranch4.y,ships[0].vx,ships[0].vy,testbranch4.d,testbranch4.s,8,testbranch4.c,16,curlr6,0.95);
		
		
		
		
		
		//starttime,startx,starty,startvx,startvy,startdir,startsize,endsize,startcolor,maxlength){
      break;
	 case "Enter": //Most of the functional shopping code goes here.
		if (dockstate == 1){//Only works in shop 1, Earf station
			if ((shopitem == 0)&&(money>19)){ //First item on list
				ships[0].hp = ships[0].maxhp;
				money = money - 20;
			}else if ((shopitem == 1)&&(money>199)){//3rd item is w3
				if (w3 == 0){//Only buy if not already bought
					w3 = 1; //Flakker is weapon 3
					money = money - 200;
					}
			}else if ((shopitem == 2)&&(money>599)){
				if (w1 == 1){//Only buy if w1 present but not upgraded
					w1 = 2; //Values >1 denote upgrades.
					money = money - 600;
					}
			}else if ((shopitem == 3)&&(money>999)){
				if (w3 == 1){//Only buy if w3 present but not upgraded
					w3 = 2; //Values >1 denote upgrades.
					bombs[2].hurt = bombs[2].hurt + 20; //bombs index 2 is player weapon 3
					money = money - 1000;
					}
			}else if ((shopitem == 4)&&(money>999)){
				if (w6 == 0){//Only buy if a1 has no upgrades
					w6 = 1; //Values >1 denote further upgrades.
					money = money - 1000;
					}
			}else if ((shopitem == 5)&&(money>799)){
				ships[0].hp = 2 * ships[0].maxhp;  //Adds hit points beyond maximum -- can't repair it!
				}
			}//end of shop 1 handling
//	var shopchart1 = [ ["$20 Repair hull","$400 w2 Mine", "$200 w3 Flakker", "$600 w1 Blaster Upgrade I (detonator)","$1000 Armor Upgrade I","$3000 Radar Upgrade I","$400 Single-use extra hull","EMPTY","EMPTY","EMPTY"]  ];
		if (dockstate == 2){//Only works in shop 2, Merz's station
			if ((shopitem == 0)&&(money>19)){ //First item on list is repair job
				ships[0].hp = ships[0].maxhp;//repair 
				money = money - 20;//bill
			}else if ((shopitem == 1)&&(money>399)){ //Second item...
				if (w2 == 0){//Only buy if not already bought
					w2 = 1; 
					money = money - 400;
					}
			}else if ((shopitem == 2)&&(money>199)){
				if (w3 == 0){//Only buy if not already bought
					w3 = 1; //Flakker is weapon 3
					money = money - 200;
					}
			}else if ((shopitem == 3)&&(money>599)){//upgrade blaster
				if (w1 == 1){//Only buy if w1 present but not upgraded
					w1 = 2; //Values >1 denote upgrades.
					money = money - 600;
					}
			}else if ((shopitem == 4)&&(money>999)){
				if (a1 == 0){//Only buy if a1 has no upgrades
					a1 = 1; //Values >1 denote further upgrades.
					ships[0].maxhp = ships[0].maxhp + 250; //bombs index 2 is player weapon 3
					money = money - 1000;
					}
			}else if ((shopitem == 5)&&(money>2999)){
				if (radarrange == 4000){//Only buy if radar has no upgrades
					radarrange = 6000;
					money = money - 3000;
					}
			}else if ((shopitem == 6)&&(money>799)){
				ships[0].hp = 2 * ships[0].maxhp;  //Adds hit points beyond maximum -- can't repair it!
				money = money - 800;
				}
		}//end of shop 2 handling//////////////////////////////////////////////////////////////////////////////

		if (dockstate == 3){//Only works in shop 3, Jupe's station
			if ((shopitem == 0)&&(money>19)){ //First item on list
				ships[0].hp = ships[0].maxhp;
				money = money - 20;
			}else if ((shopitem == 1)&&(money>399)){ //Second item is weapon 2, a mine
				if (w2 == 0){//Only buy if not already bought
					w2 = 1; //enables weapon
					money = money - 400;
					}
			}else if ((shopitem == 2)&&(money>199)){//3rd item is w3
				if (w3 == 0){//Only buy if not already bought
					w3 = 1; //Flakker is weapon 3
					money = money - 200;
					}
			}else if ((shopitem == 3)&&(money>999)){
				if (w4 == 0){//Only buy if not already bought
					w4 = 1; //Railgun is w4
					money = money - 1000;
					}
			}else if ((shopitem == 4)&&(money>599)){
				if (w1 == 1){//Only buy if w1 present but not upgraded
					w1 = 2; //Values >1 denote upgrades.
					money = money - 600;
					}
			}else if ((shopitem == 5)&&(money>1199)){
				if (w2 == 1){//Only buy if w3 present but not upgraded
					w2 = 2; //Values >1 denote upgrades.
					money = money - 1200;
					}
			}else if ((shopitem == 6)&&(money>999)){
				if (w3 == 1){//Only buy if w3 present but not upgraded
					w3 = 2; //Values >1 denote upgrades.
					bombs[2].hurt = bombs[2].hurt + 20; //bombs index 2 is player weapon 3
					money = money - 1000;
					}
			}else if ((shopitem == 7)&&(money>999)){
				if (a1 == 0){//Only buy if a1 has no upgrades
					a1 = 1; //Values >1 denote further upgrades.
					ships[0].maxhp = ships[0].maxhp + 250; //bombs index 2 is player weapon 3
					money = money - 1000;
					}
			}else if ((shopitem == 8)&&(money>1999)){
				if (s1 == 0){//Only buy if s1 has no upgrades
					s1 = 1; //Values >1 denote further upgrades.
					ships[0].maxshield = ships[0].maxshield + 200; //Incrementing allows me to rebalance initial maximum
					money = money - 2000;  //Regen rate is unchanged, will be upgradable soon
					}
			}else if ((shopitem == 9)&&(money>799)){
				ships[0].hp = 2 * ships[0].maxhp;  //Adds hit points beyond maximum -- can't repair it!
				}
		}//end of shop 3 handling///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//[ ["$20 Repair hull","$1000 w4 Railgun","$2400 w5 SpreadShot Cannon","$4000 w6 Lazzor","$6000 w7 Double Rainbow","$4000 w8 Spectral Disintegrator", "$10000 w9 Bapadoop","$2000 Shield Upgrade I","$800 Single-use extra hull","EMPTY"]  ];
		if (dockstate == 4){//Only works in shop 4, Anus's station
			if ((shopitem == 0)&&(money>19)){ //First item on list
				ships[0].hp = ships[0].maxhp;
				money = money - 20;
			}else if ((shopitem == 1)&&(money>999)){ //Second item is weapon 4, railgun
				if (w4 == 0){//Only buy if not already bought
					w4 = 1; //enables weapon
					money = money - 1000;
					}
			}else if ((shopitem == 2)&&(money>2399)){//3rd item is w5, spreadcannon
				if (w5 == 0){//Only buy if not already bought
					w5 = 1;
					money = money - 2400;
					}
			}else if ((shopitem == 3)&&(money>3999)){//w6 lazzzor
				if (w6 == 0){//Only buy if not already bought
					w6 = 1; 
					money = money - 4000;
					}
			}else if ((shopitem == 4)&&(money>5999)){
				if (w7 == 0){//Only buy if w1 present but not upgraded
					w7 = 1; //Values >1 denote upgrades.
					money = money - 6000;
					}
			}else if ((shopitem == 5)&&(money>3999)){
				if (w8 == 0){//Only buy if w3 present but not upgraded
					w8 = 1; //Values >1 denote upgrades.
					money = money - 4000;
					}
			}else if ((shopitem == 6)&&(money>9999)){
				if (w9 == 0){//Only buy if w3 present but not upgraded
					w9 = 1; //Values >1 denote upgrades.
					money = money - 10000;
					}
			}else if ((shopitem == 7)&&(money>1999)){
				if (s1 == 0){//Only buy if a1 has no upgrades
					s1 = 1; //Values >1 denote further upgrades.
					ships[0].maxhp = ships[0].maxhp + 250; //bombs index 2 is player weapon 3
					money = money - 2000;
					}

			}else if ((shopitem == 8)&&(money>799)){
				ships[0].hp = 2 * ships[0].maxhp;  //Adds hit points beyond maximum -- can't repair it!
				money = money - 800;
				}
		}//end of shop 4 handling///////////////////////////////////////////////////////////////////////////////////////////////////////////////
      break;
    default:
      return; // Quit when this doesn't handle the key event.
  } //end event key handling switch
  event.preventDefault();// Cancel the default action to avoid it being handled twice
}, true);	//end of event key handling, not clear what the ", true);" is about		
}//end update function
document.addEventListener("mousemove", mouseMoveHandler, false);
function mouseMoveHandler(e) {
    mdx =  e.clientX - canvas.width/2;
	mdy =  e.clientY - canvas.height/2;
	moused = -1*Math.atan2(mdx,mdy) - Math.PI/2;
	mousedistance = Math.sqrt(mdx*mdx+mdy*mdy);
	//clicktester=clicktester+1;  //Apparently also fucked, but not normally a problem.
} //I should figure that out better.
document.addEventListener("mousedown", mouseDownHandler, false);
function mouseDownHandler(e) {
mousestate = e.buttons;
if (mousestate==1){ //if it's the left button
	if (wep == 1){
		if ((w1 > 1)&&(playerbombs[0].timer > 4)){playerbombs[0].timer = 6;} //This remote detonation code doesn't work with mousedown for some reason
		else if ((energy > 20)&&(w1>0)){ //If ship has energy and weapon 1.
			ships[0].launchbomb(playerbombs[0],12, 120);  //launch bomb[0] 12 pixels per frame, timed to explode in 120 frames.
			energy = energy - 20; //w1 costs 20 energy
			}
		}
	if (wep == 2){
		if ((w2 > 1)&&(playerbombs[1].timer > 4)){playerbombs[1].timer = 6;} 
		else if ((energy > 50)&&(w2>0)){ 
			ships[0].launchbomb(playerbombs[1],1, 1800);//A mere 1 pixel per frame, but for 1800 frames (60s).
			energy = energy - 50;
			}
		}
	if (wep == 3){
		 if ((energy > 30)&&(w3>0)){ //If ship has energy and weapon 3.
				ships[0].launchbomb(playerbombs[2],16, 12);
				energy = energy - 33;
			}
		}						
	if (wep == 4){
		if ((energy > 75)&&(w4>0)){ //If ship has energy and weapon 4.
				ships[0].launchbomb(playerbombs[3],24, 120);  
				energy = energy - 75; 
			}
		}
	if (wep == 5){
		if (energy > 40){ //If ship has energy
			var shipdsave = ships[0].d; 
			//var spread = 0.4;
			if (mousedistance>(canvas.width*0.6)){var spread = (Math.PI*0.75)/(canvas.width*0.6/32);}
			else if (mousedistance<32){var spread = (Math.PI*0.75)/(32/32);}
			else {var spread = (Math.PI*0.75)/(mousedistance/32);}
			ships[0].d = shipdsave - spread; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[4],12, 80); //launches 1st of four bombs
			ships[0].d = shipdsave - spread/3; //rotates to next position in spread...
			ships[0].launchbomb(playerbombs[5],12, 80);//launches next bomb...
			ships[0].d = shipdsave + spread/3;
			ships[0].launchbomb(playerbombs[6],12, 80);
			ships[0].d = shipdsave + spread;
			ships[0].launchbomb(playerbombs[7],12, 80);					
			ships[0].d = shipdsave;//restores original ship direction
			energy = energy - 40; 
			}
		}
	if (wep == 6){
		if (energy > 30){ //If ship has energy
			var i = ships.length;
			while (i>1){//For all ships except 0
				i = i - 1; 
				if (ships[0].distance(ships[i])<500){
					var ptest = pointingat(ships[0].directionof(ships[i]),ships[0].d,ships[0].distance(ships[i]),ships[i].s)
					if (ptest == 1){
						ships[i].damage(50);
						var x = ships[i].x - ships[0].x + canvas.width/2;
						var y = ships[i].y - ships[0].y + canvas.height/2;
						}
					//function pointingat(objdir,dir,distance,size){ //are you pointing at a thing?
					}
				}
			context.beginPath();
			context.moveTo(canvas.width/2, canvas.height/2);
			context.lineTo(canvas.width/2+Math.cos(ships[0].d)*500,canvas.height/2+Math.sin(ships[0].d)*500);
			context.strokeStyle = "red";
			context.stroke();	
			energy = energy - 30; 
			}
		}				
	
	if (wep == 7){
		if (energy > 60){ //If ship has energy
			var shipdsave = ships[0].d; 
			if (mousedistance>(canvas.width*0.6)){var spread = (Math.PI*0.25)/(canvas.width*0.6/32);}
			else if (mousedistance<32){var spread = (Math.PI*0.25)/(32/32);}
			else {var spread = (Math.PI*0.25)/(mousedistance/32);}
			ships[0].d = shipdsave - spread*5.5; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[8],24, 24); //launches 1st of four bombs
			ships[0].d = shipdsave - spread*4.5; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[9],24, 24); //launches 1st of four bombs
			ships[0].d = shipdsave - spread*3.5; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[10],24, 24); //launches 1st of four bombs
			ships[0].d = shipdsave - spread*2.5; //rotates to next position in spread...
			ships[0].launchbomb(playerbombs[11],24, 24);//launches next bomb...
			ships[0].d = shipdsave - spread*1.5; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[12],24, 24); //launches 1st of four bombs
			ships[0].d = shipdsave - spread/2; //rotates to next position in spread...
			ships[0].launchbomb(playerbombs[13],24, 24);//launches next bomb...
			ships[0].d = shipdsave + spread/2;
			ships[0].launchbomb(playerbombs[14],24, 24);
			ships[0].d = shipdsave + spread*1.5;
			ships[0].launchbomb(playerbombs[15],24, 24);		
			ships[0].d = shipdsave + spread*2.5;
			ships[0].launchbomb(playerbombs[16],24, 24);
			ships[0].d = shipdsave + spread*3.5;
			ships[0].launchbomb(playerbombs[17],24, 24);	
			ships[0].d = shipdsave + spread*4.5;
			ships[0].launchbomb(playerbombs[18],24, 24);	
			ships[0].d = shipdsave + spread*5.5;
			ships[0].launchbomb(playerbombs[19],24, 24);				
			ships[0].d = shipdsave;//restores original ship direction
			energy = energy - 64; 
			}
		}
	if (wep == 9){
		if ((energy > 75)&&(w9>0)){ //If ship has energy and weapon 4.
				ships[0].launchbomb(playerbombs[26],16, 120); 
				playerbombs[26].hp = 1000;//weapon 9 uses a special bomb that can bounce of planets				
				energy = energy - 80; 
			}
		}
	if (wep == 0){
		if ((energy > 75)&&(w0>0)){ //If ship has energy and weapon 4.
				ships[0].launchbomb(playerbombs[27],24, 120);  
				energy = energy - 50; 
			}
		}
	}
else if (mousestate==2){//if its the right button
	if (dockstate == 1){
		terranoutpost.undock(ships[0]);
		dockstate = 0;
		}
	if (dockstate == 2){
		merzoutpost.undock(ships[0]);
		dockstate = 0;
		}
	if (dockstate == 3){
		jupeoutpost.undock(ships[0]);
		dockstate = 0;
		}
	if (dockstate == 4){
		anusoutpost.undock(ships[0]);
		dockstate = 0;
		}
	ships[0].thrust = 2*thrustmultiplier;} //pushes player in direction this.d
	}
document.addEventListener("mouseup", mouseUpHandler, false);
function mouseUpHandler(e) {
mousestate = e.buttons;
}

    </script>
</body>
</html>