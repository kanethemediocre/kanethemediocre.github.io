<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8"> 
    <title>Umo Space 151 by KaneTheMediocre</title>
    <style></style>
</head>
<body class="myElement" oncontextmenu="return false;">
    <canvas id="gameCanvas" width="1600" height="900"></canvas>
    <script>
        // declare variables
        const FPS = 30;
        var canvas, context;
        canvas = document.getElementById("gameCanvas"); //canvas is the draw sauce.
        context = canvas.getContext("2d");
		var time = 0;
		var system = 1; //0 is menu, 1 is home system.  Higher numbers eventually refer to procedurally generated systems.
		var thrustmultiplier = 1; //Adjusts thruster sensitivity
		var launchmultiplier = 1; //not really used
		var navtarget = 0; // Compass points to planets[navtarget]
		var navactive = 1; //nav computer starts off, 1 is planetary, 2 is for stations
		var shiptarget = 1; // Targets ships[1]
		var nmeactive = 1; //targeting computer starts off
		var mapactive = 2; //2 is corner map, 1 is full map, 0 is no map
		var mapscale = 128; //Map zoom
		var energy = 50;
		var thruster = 50;
		var radarrange = 20000;//Defines distance a ship can be from the player and still be targetable
		var money = 1000;
		var gotmoney = [0,0]; //For animation, [$ amount, frames left in animation]
		var drawdistance = Math.sqrt(canvas.width*canvas.width/4+canvas.height*canvas.height/4)+200;
		var w1 = 1; //Presence or weapons, upgrades etc.
		var w2 = 0; //Upgraded weapons have values >1
		var w3 = 0; 
		var w4 = 0; 
		var w5 = 1;
		var w6 = 1;
		var w7 = 1;
		var w8 = 1;
		var w9 = 1;
		var w0 = 1;
		var wstatus = [w0,w1,w2,w3,w4,w5,w6,w7,w8,w9];//not used yet, index numbers match weapon numbers, will replace w# variables.
		var wnames = ["Probe","Blaster","Mine","Flakker","Railgun","SpreadShot", "Lazzzor","Double Rainbow","Spectral Disintigrator","Bapadoop"]; //also not used yet
		var a1 = 0; //armor upgrades
		var s1 = 0; //Shield upgrades
		var wep = 1; //Currently selected weapon
		var moused = 0; //Direction currently indicated by mouse
		var mousedistance = 0; // Distance to mouse cursor
		var mousestate = 0;
		var shop = 0; //O indicates not shopping, 1 indicates a shop, 2 might indicate a different shop....
        var shopitem = 0; //Indicates item selected in the shop.
		var storystate = 0;//Player progress in story missions
		var dockstate = 0; //Player dock status, 0 is undocked, 1 is docked at station 1, etc...
		var shipsinrange = [];//To help guide what ships are targetable by the player, I'm generating a short list / shallow copy of nearby ships.
		var radarrange = 4000;//Defines distance a ship can be from the player and still be targetable
		var closestdistance = 999999;//needs to be larger than radarrange 
		var closestindex = 0; //defaults to self-targeting if no ships in range
        setInterval(update, 1000 / FPS);// set up interval (game loop)
		function showchart(chartdataxy, xspace, yspace, x,y){ //displays chart with specified cell dimensions and position
			 var i = 0 //assumes each column is same length, otherwise error
			 var j = 0;
			 while (i<chartdataxy.length){
				var cellposx = x+i*xspace;
				j = 0;
				while (j<chartdataxy[0].length){
					var cellposy = y+j*yspace;
					context.fillText(chartdataxy[i][j],cellposx,cellposy);
					j=j+1;
					}
				i=i+1;
				}
			 }
		//var cxytest = [ ["first", "column", "of", "words"], ["2nd", "column", "of", "words"]       ];
		//showchart(cxytest, 64, 16, 300,300);
		function showmessage(message){ //Displays a message, breaking it up into multiple lines as needed.  No word continuity or overflow handling yet.
			var maxlength = (canvas.width-840)/11; //estimating font width to 10 px, allotting 150 px margins
			var maxlines = canvas.height/(24*6); //estimating font height to 24 px, allotting 1/6 of screen, only used for overflow handling (eventually)
			var starty = Math.floor(canvas.height*5/6 - 24); //allotting bottom 1/6 of screen + 24 px fudge factor
			var startx = 420;
			var lines = 1 + Math.floor(message.length/maxlength);
			context.font='16px Courier New';
			context.fillStyle = "white";  
			var line = 0;
			while (line<(lines)){//while there are still lines of text to draw...
				context.fillText(message.slice(line*maxlength, (line+1)*(maxlength)),startx,(starty + line*24));
				line = line + 1;
				}//slice(startofline,endofline,startx,startyofline)
			}
		function targetchart(targets,xspace,yspace,x,y){
			context.font='12px Courier New';
			var sorttargets = [];//No sorting yet
			var i = 0 //assumes each column is same length, otherwise error
			while(i<targets.length){
				var cellposx = x;
				var cellposy = y+i*yspace;
				context.fillStyle = targets[i][0].c
				context.fillText(targets[i][0].name,cellposx,cellposy);
				var cellposx = x+xspace;
				context.fillText(targets[i][1],cellposx,cellposy);
				i=i+1;
				}
			context.fillStyle = "white";  
			}
		class Radio {
		constructor(intromessage){
			this.msgstart = 0; //Time that current message began
			this.sender = "Tutorial"; //Who sent the message
			this.senderx = 420;//Math.floor(canvas.width/2) - Math.floor(this.sender.length/2);
			this.sendery = Math.floor(canvas.height*5/6 - 50);
			this.msgnow = intromessage; //Text of message
			this.msgtime = Math.floor(this.msgnow.length*1.5) + 120; //message duration
			}
		newmsg(sndr, msg, thetime){//used to put a new message into the object
			this.msgstart = thetime;
			this.sender = sndr;
			this.senderx = Math.floor(canvas.width/2) - Math.floor(this.sender.length/2);
			this.msgnow = msg;
			}
		display(thetime){
			if (thetime<(this.msgstart+this.msgtime)){			
				context.font='16px Courier New';
				context.fillStyle = "red";  
				context.fillText(this.sender+":",this.senderx,this.sendery);
				showmessage(this.msgnow.slice(0, (thetime-this.msgstart) ));
				}
			}
		}////end class radio
		function drawaskey(xpos,ypos,keystring,keycolor){//seems to cause graphical glitches after a few minutes runtime
			context.font='16px Courier New';
			context.fillStyle = keycolor;  
			context.fillText(keystring,xpos,ypos);
			context.strokeStyle = keycolor;
			context.rect(xpos-8,ypos-16,24,24);
			context.stroke();
			}
		function drawpolarpoly(px,py,thetalist, radiuslist, size, color, dir){
		//requires, does not verify, that thetalist.length==radiuslist.length, thetalist.length>2, color be valid
			var fx = px + Math.cos(dir+thetalist[0])*size*radiuslist[0];
			var fy = py + Math.sin(dir+thetalist[0])*size*radiuslist[0];
			context.fillStyle = color; //Now actual drawing of the things
			context.beginPath();
			context.moveTo(fx, fy); 
			i = thetalist.length;
			while(i>0){
				i=i-1;
				var ix = px + Math.cos(dir+thetalist[i])*size*radiuslist[i];
				var iy = py + Math.sin(dir+thetalist[i])*size*radiuslist[i];
				context.lineTo(ix, iy);
			}
			context.fill();	
		}
		function draworthopoly(px,py, xlist, ylist, size, color, dir){//Not really useful, because this
			var fx = px + xlist[0]*size; //needs to be transformed to polar coords to rotate it anyways
			var fy = py + ylist[0]*size;
			context.fillStyle = color; //Now actual drawing of the things
			context.beginPath();
			context.moveTo(fx, fy); 
			i = xlist.length;
			while(i>0){
				i=i-1;
				var ix = px + xlist[i]*size;
				var iy = py + ylist[i]*size;
				context.lineTo(ix, iy);
			}
			context.fill();	
			}
		function randpolarpoly(sides, minradius){//Polygons will be symmetrical, vertices evenly spaced
			spacing = 2*Math.PI/sides; //Needs at least 3.  Or 4, seems not to work right with odd numbers
			firstradius = Math.random()*(1-minradius) + minradius; //Minimum radius to make things less spiky
			vertices = [[0],[firstradius]];//Array of arrays, first element is list of angles, 2nd element is list of radii.
			i = 0;
			while (i<sides/2){ //First half is random
				i=i+1;
				vertices[0].push(spacing*i);
				vertices[1].push(Math.random()*(1-minradius) + minradius);
				}
			while (i<sides){ //2nd half matches first
				i=i+1;
				vertices[0].push(spacing*i);
				vertices[1].push(vertices[1][sides-i]);
				}
			return vertices; 
			}
		function normalizepoly(vertices){//Make the largest radii equal to 1, scale the others proportionally.
			var maxr = 0;
			i = vertices[1].length;
			while (i>0){//finds the largest radii
				i=i-1;
				if (vertices[1][i]>maxr){maxr = vertices[1][i];}
				}
			i = vertices[1].length;
			while (i>0){//Scales radii to 1
				i=i-1;
				vertices[1][i]=vertices[1][i]/maxr;
				}
			}
		function randvowel(){
			var vowels = "aeyuio";
			var vindex = Math.floor(Math.random()*vowels.length);
			return vowels[vindex];
			}
		function randconsonant(){
			var consonants = "zxcvbnmsdfghjklqwrtyp";
			var cindex = Math.floor(Math.random()*consonants.length);
			return consonants[cindex];
			}
		function randname(namelength){//Creates a random name of length namelength, with no more than 2 vowels or consonants in a row
			var lastchartype = Math.floor(Math.random()*2); //0 for consonant, 1 for vowel;
			var lastchartype2 = Math.floor(Math.random()*2); //2nd to last....
			var thischartype = Math.floor(Math.random()*2); //0 for consonant, 1 for vowel;
			var thename = ""; //Start with an empty name
			if (lastchartype2 == 0){thename=thename+randconsonant();}else{thename=thename+randvowel();}
			if (lastchartype == 0){thename=thename+randconsonant();}else{thename=thename+randvowel();}
			var i = namelength;
			while (i>2){
				i=i-1;
				if (lastchartype == lastchartype2){ //if last two characters are same type,
					if (lastchartype == 0){thischartype = 1;}else{thischartype = 0;} //make other type
					}else {thischartype = Math.floor(Math.random()*2);}//otherwise pick randomly
				if (thischartype == 0){thename=thename+randconsonant();}else{thename=thename+randvowel();}
				lastchartype2 = lastchartype; //Keep track of last two characters
				lastchartype = thischartype; //so we can not have 3 vowels or 3 consonants sequentially
				}
			return thename;
			}
		var testname = randname(8);
		function randcolor(){
			var thecolors = ["hotpink","deeppink","fuchsia","darkviolet","purple","indigo","salmon","crimson","red","darkred","orange","orangered","gold","yellow","khaki","lime","mediumspringgreen","seagreen","green","darkgreen","olive","teal","aqua","steelblue","lightskyblue","deepskyblue","blue","navy","tan","chocolate","sienna","maroon","silver","darkgrey","dimgrey"];
			return thecolors[Math.floor(Math.random()*thecolors.length)];
			}
		function drawmap(mplanets,scale,xx,yy, px, py){//scale of -1 indicates autozoom?  xx,yy are screen coords
					var i = mplanets.length; //px, py are perspective x and y
					var x = 0;
					var y = 0;
					var size = 1;
					var xzoombox = canvas.width/scale;
					var yzoombox = canvas.height/scale
					context.beginPath(); //rectangle centered on x,y
					context.rect(xx-xzoombox/2,yy-yzoombox/2, xzoombox, yzoombox); //2*this.s wide
					context.lineWidth = 1; 
					context.strokeStyle = "yellow";
					context.stroke();	
					while (i>0){
						i = i-1;
						x = xx + mplanets[i].x/scale - px/scale ;
						y = yy + mplanets[i].y/scale - py/scale;
						size = 1+ Math.floor(mplanets[i].s/scale);
						context.beginPath();
						context.strokeStyle = mplanets[i].c; //drawing planet
						context.arc(x, y, size, 0, 2 * Math.PI, false); 
						context.lineWidth = 1; 
						context.stroke();	//ok now actually draw it.	
						if (mplanets[i].parentid == 0){//If planet
							oradius = mplanets[0].distance(mplanets[i])/scale;
							context.beginPath();
							context.strokeStyle = "darkslategrey"; //drawing faint orbit radius
							context.arc(xx-px/scale, yy-py/scale, oradius, 0, 2 * Math.PI, false); 
							context.lineWidth = 1; 
							context.stroke();	//ok now actually draw it.	
							}
						}
					}
		//drawmap(planets,1000,canvas.width/2,200);//scale of -1 indicates autozoom?  xx,yy are screen coords
		function pointingat(objdir,dir,distance,size){ //are you pointing at a thing?
			var as = Math.atan2(size,distance); //how much angle does the thing occupy?
			var dd = dir - objdir; //How much off the actual direction are you pointing?
			while (dd > Math.PI){dd = dd - 2*Math.PI;} //This reduces the angle difference to within +- Math.PI
			while (dd < -1*Math.PI){dd = dd + 2*Math.PI;}
			while (as > Math.PI){as = as - 2*Math.PI;} //This reduces the angle difference to within +- Math.PI
			while (as < -1*Math.PI){as = as + 2*Math.PI;}
			if ((dd<as)&&(dd>-1*as)){//-1*anglesize < deltadir < anglesize
				return 1;
				}else {return 0;}
			}
		class Umo { //Universal Moving Object
		constructor(xxx, yyy, sss, ccc) {
			this.name = "Cactus Fantastico";
			this.type = "unspecified"; //I might use this to identify different
			this.x = xxx; //x
			this.y = yyy; //y
			this.c = ccc; //color
			this.s = sss; //size
			this.d = 0; // direction
			this.vx = 0; //start with 0 velocity 
			this.vy = 0;
			this.vd = 0; //0 rotation 
			this.m = this.s*this.s*this.s; //So far only used by gravitate function.
			this.thrust = 0;
			this.deadtime = 0;   //0 is alive.  N is dead for N more frames.
			this.hp = 100 ; //This is used for destructible entities to track health
			this.maxhp = 100;
			this.timer = 0; //Used for bombs.  Could maybe be consolidated with deadtime.
			this.hurt = 16 ; //used for bombs and planets.  Determines damage.
			this.boombuff = 0.5 ; // used for bombs.  Multiplies blast radius
			this.shield = 50; //for ships, mostly
			this.maxshield = 50; 
			this.shieldregen = 1;
			this.polyradius = [1,1,1]; //Default values are the triangle originally
			this.polytheta = [0,0.8*Math.PI,1.2*Math.PI];	//used for ship drawing
			this.level = 1; //Describes difficulty of a given ship
			this.parentid = 0;
			this.active = 1; //Flag indicating if ship (or planet's ships) needs to be considered by the game engine
			}
		update1(){ //Pure motion update.
			this.x = this.x + this.vx;
			this.y = this.y + this.vy;
			this.d = this.d + this.vd;
			}
		distance(relation){
			var dx = this.x - relation.x; 
			var dy = this.y - relation.y;
			return Math.sqrt(((dx)*(dx) + (dy)*(dy)));	
		}
		deltav(relation){ //returns magnitude only
			var dvx = this.vx - relation.vx; 
			var dvy = this.vy - relation.vy;
			return Math.sqrt(((dvx)*(dvx) + (dvy)*(dvy)));			
			}
		deltav2(relation){//returns magnitude, direction (polar vector)
			var dvx = this.vx - relation.vx; 
			var dvy = this.vy - relation.vy;
			var mag = Math.sqrt(((dvx)*(dvx) + (dvy)*(dvy)));	
			var dir =  -1*Math.atan2(dvx,dvy) - Math.PI/2;
			return [mag,dir];
			}
		match(that){  //This basically synchronizes two moving bodies
			this.x = that.x; //same position
			this.y = that.y;
			this.vx = that.vx;//same velocity
			this.vy = that.vy;
			this.d = that.d; //same direction
		}
		damage(dmg){ //Automatically applies damage to shield and hitpoints as appropriate
			if (this.shield > dmg){
				this.shield = this.shield - Math.floor(dmg);
			}else{
				this.hp = this.hp - Math.floor(dmg) + this.shield;
				this.shield = 0;
				}
			}
		collide(that){ //circular collision function
			if (this.distance(that) < (this.s + that.s)) {return true; }else{return false;} 
			} //Doesn't bounce or damage, just returns 1 if a collision is occuring.
		directionof(destination){
			var dx = this.x - destination.x; 
			var dy = this.y - destination.y;
			var	dirof = 0;	
			dirof = -1*Math.atan2(dx,dy) - Math.PI/2;//Sort of trial and error for this
			return dirof;	
			}
		track(target) { //Basic tracking algorithm.  Can be used to track any object compatible 
			var td = this.directionof(target); //with directionof, which just needs a .x and .y to work with
			var dd = this.directionof(target)-this.d;
			while (dd > Math.PI){dd = dd - 2*Math.PI;} //This reduces the angle difference to within +- Math.PI
			while (dd < -1*Math.PI){dd = dd + 2*Math.PI;} //which 
			if (dd > .04){ this.vd =+.03; }
			else if (dd < -0.04){ this.vd = -.03; }
			else {	this.vd = 0; }
			}
		gravitate(pulled){ //For planets.
			var dx = this.x - pulled.x; 
			var dy = this.y - pulled.y;
			var distance = Math.sqrt(((dx)*(dx) + (dy)*(dy)));
			var gconstant = 0.0003;
			var magnitude = (gconstant*this.m)/(distance*distance);
			var dcos = dx/distance;
			var dsin = dy/distance;
			pulled.vx = pulled.vx + magnitude*dcos;
			pulled.vy = pulled.vy + magnitude*dsin;
			}
		gravitategroup(pulled){ //Input is a list of objects to pull.  
			var i = pulled.length;
			var dx, dy, distance, gconstant, magnitude, dcos, dsin;
			while (i>0){ //Cycles through list of objects to be pulled
				i=i-1;
				dx = this.x - pulled[i].x; 
				dy = this.y - pulled[i].y;
				distance = Math.sqrt(((dx)*(dx) + (dy)*(dy)));
				gconstant = 0.0003;
				magnitude = (gconstant*this.m)/(distance*distance);
				dcos = dx/distance;
				dsin = dy/distance;
				pulled[i].vx = pulled[i].vx + magnitude*dcos;
				pulled[i].vy = pulled[i].vy + magnitude*dsin;
				}
			}	
		push(mag,dir){
			this.vx = this.vx + mag*Math.cos(dir);
			this.vy = this.vy + mag*Math.sin(dir);
		}
		circlecollide(that){ //circular bouncing
			var dir = this.directionof(that);
			var dvx = this.vx - that.vx;
			var dvy = this.vy - that.vy;
			var thedeltav = this.deltav2(that);
			var dvmag = thedeltav[0];
			var dvdir = thedeltav[1];
			var pushmag = Math.cos(dir - dvdir)*dvmag;
			if (this.distance(that) < (this.s + that.s)) {
				that.push(-2*pushmag, (this.directionof(that)));
				that.damage(this.hurt); 
				}
			}
		bombcollide(that){ //explodes on contact, damages every frame in explosion
			if (this.distance(that) < (this.s + that.s)) {
				that.damage(this.hurt); //Automatically proportional based on time spent inside 
				if (this.timer>6){this.timer = 6;}//sets off explosion by setting timer to start of explosion
				}
			}
		squarebouncecollide(that){
			var dx = this.x-that.x;
			var dy = this.y-that.y;
			if ((( dx<(this.s+that.s) )&&( dx>-1*(this.s+that.s) ))&&(( dy<(this.s+that.s) )&&( dy>-1*(this.s+that.s) ))) {
				//Checks if in x range AND in y range.  
				var dvx = this.vx - that.vx;
				var dvy = this.vy - that.vy;
				if (dx*dx > dy*dy){ //closer in Y than X, bounce off vertical wall.  Squared to make postive for comparison
					that.vx = that.vx + 2*dvx;//Adds double the X-axis difference to cancel and reverse the X velocity difference.
					that.damage(dvx); //damage proportional to closing velocity
					}
				if (dy*dy > dx*dx){ //closer in X than Y, bounce off horizontal wall
					that.vy = that.vy + 2*dvy;
					that.damage(dvy);
					}
				}
			}
		drawship(viewx, viewy){ //Ships are drawn as polar polygons, a triangle is the default.  Viewx/viewy are camera center
			var x = this.x - viewx + canvas.width/2; //normally camera center being the player ship.
			var y = this.y - viewy + canvas.height/2;
			drawpolarpoly(x,y,this.polytheta, this.polyradius, this.s, this.c, this.d);//ship polyon
			var shieldthick = Math.floor(this.shield*4/this.maxshield); //shield
			if (shieldthick>0){ //Needs to not render at all sometimes because linewidth of 0 is ignored instead of invisible.
				context.beginPath();  //So instead of not rendering, it will render at most recent thickness (often max)
				context.arc(x, y, this.s+2, 0, 2 * Math.PI, false); //until linewidth of 1 is reached.
				context.lineWidth = shieldthick;
				context.strokeStyle = "blue";
				context.stroke();	
			}//Now a health bar/////////////////////////////////////////
			var prop = this.hp / this.maxhp;
			var hpc = "green"; //health bar color depends on healthiness
			if (prop < 0.66){ hpc = "yellow"; }
			if (prop < 0.33){ hpc = "red"; }
			context.fillStyle = hpc; //health bar color depends on ship condition
            context.fillRect(x-this.s/2, y+this.s, Math.floor(this.s*prop), 4);
			}
		drawplanet(viewx, viewy){ //input variables are player ship/camera position
			var x = this.x - viewx + canvas.width/2; //this function draws object as a circle,
			var y = this.y - viewy + canvas.height/2; //and labels it
			context.beginPath();
			context.strokeStyle = this.c; //sets planet color
			context.arc(x, y, this.s, 0, 2 * Math.PI, false); //draws the circle
			context.lineWidth = 16; //circle is thicc
			context.stroke();	//ok now actually draw it.
			context.fillStyle = "white"; 
			context.font='20px Arial';
			context.fillText(this.name,x,y);		
		}
		drawbomb(viewx, viewy){ //Bombs are also drawn as circles, but not labelled.
			var x = this.x - viewx + canvas.width/2;
			var y = this.y - viewy + canvas.height/2;
			context.beginPath();
			context.strokeStyle = this.c;
			context.arc(x, y, this.s, 0, 2 * Math.PI, false);
			context.lineWidth = 4;
			context.stroke();		 
		}
		drawstation(viewx, viewy){ //input variables are player ship position
			var x = this.x - viewx + canvas.width/2;//stations are squares for now
			var y = this.y - viewy + canvas.height/2;
			drawpolarpoly(x,y,this.polytheta, this.polyradius, this.s, this.c, this.d);//ship polyon
			context.fillStyle = "white";
			context.font='20px Arial';
			context.fillText(this.name,x,y);		
		}
		dock(dship){
			var offsetd = 0;
			var offsetr = 128;
			dship.match(this);
			dship.x = this.x+offsetr*Math.cos(this.d+offsetd);
			dship.y = this.y+offsetr*Math.sin(this.d+offsetd);
			dship.d = this.d;
			}
		undock(dship){
			var offsetd = 0;
			var offsetr = 200;
			dship.match(this);
			dship.x = this.x+offsetr*Math.cos(this.d+offsetd);
			dship.y = this.y+offsetr*Math.sin(this.d+offsetd);
			dship.d = this.d;
			dship.push(2,this.d);
			}
		drawreticle(viewx, viewy){ //input variables are player ship / camera position
			var x = this.x - viewx + canvas.width/2; //draws reticle around object
			var y = this.y - viewy + canvas.height/2; //circular reticle.
			context.beginPath();
			context.arc(x, y, this.s+24, 0, 2 * Math.PI, false);
			context.lineWidth = 2;
			context.strokeStyle = "white";
			context.stroke();	
		}
		drawcompass(targetship, compassx, compassy, compasssize){  //Draws a triangle pointing in direction of targetship
			var de = targetship.directionof(this); //targetship doesn't actually have to be a ship
			var tipx = Math.cos(de)*compasssize + compassx; //triangle points
			var tipy = Math.sin(de)*compasssize + compassy; //sort of from polar coordinates
			var taillx = Math.cos(de + 0.9*Math.PI)*compasssize + compassx;
			var tailly = Math.sin(de + 0.9*Math.PI)*compasssize + compassy;
			var tailrx = Math.cos(de + 1.1*Math.PI)*compasssize + compassx;
			var tailry = Math.sin(de + 1.1*Math.PI)*compasssize + compassy;
			context.fillStyle = this.c; //Now actual drawing of the things
			context.beginPath(); 
			context.moveTo(tipx, tipy); //Could be consolidated for less lines with above.
			context.lineTo(taillx, tailly);
			context.lineTo(tailrx, tailry);
			context.lineTo(tipx, tipy);
			context.fill();
			context.font='12px Arial';
			context.fillStyle = "white";
			//context.fillText(this.name,compassx-8,compassy - 48);
			context.fillText(this.name,compassx-8,compassy - compasssize);
			context.fillStyle = "white";
			//context.fillText(this.hp,compassx-8,compassy - 32);
			context.fillStyle = "white";
			context.fillText(Math.floor(this.distance(targetship)),compassx-16,compassy + compasssize);
			}// end compass stuff
			
		drawcompass2(targetship, compassx, compassy, compasssize){  //Draws a triangle pointing in direction of targetship
			var de = this.directionof(targetship); //targetship doesn't actually have to be a ship
			var tl = [0,0.05,0.4,-0.4,-0.05];
			var rl = [1,0.85,0.8,0.8,0.85];
			drawpolarpoly(compassx,compassy,tl, rl, compasssize, "yellow", de);//function drawpolarpoly(px,py,thetalist, radiuslist, size, color, dir){
			drawpolarpoly(compassx,compassy,targetship.polytheta, targetship.polyradius, compasssize*0.5, targetship.c, targetship.d);//function drawpolarpoly(px,py,thetalist, radiuslist, size, color, dir){
			context.font='12px Arial';
			context.fillStyle = "white";
			//context.fillText(this.name,compassx-8,compassy - 48);
			context.fillText(targetship.name,compassx-8,compassy - compasssize);
			context.fillStyle = "white";
			//context.fillText(this.hp,compassx-8,compassy - 32);
			context.fillStyle = "white";
			context.fillText(Math.floor(this.distance(targetship)),compassx-16,compassy + compasssize);
			}// end compass stuff
		updateship(theplanets){//Unfortunately I need access to the list of planets to handle ship respawning.
			if ((thruster > 0)&&(this.thrust > 0)){ //skips these calculations if no thrust
				this.vx = this.vx + this.thrust*Math.cos(this.d);
				this.vy = this.vy + this.thrust*Math.sin(this.d);
				thruster = thruster - this.thrust*12;
				}
			this.thrust = 0; //keeps thrusters momentary
			this.x = this.x + this.vx;
			this.y = this.y + this.vy;
			this.d = this.d + this.vd;
			if ((this.hp < 0) && (this.hp !==-1000)){ this.killship(1800); }
			this.deadtime = this.deadtime - 1;
			if (this.thruster > 100){ this.thruster = 100; }
			this.energy = this.energy + 1;
			if (this.energy > 100){	this.energy = 100; }				
			this.shield = this.shield + this.shieldregen;
			if (this.shield > this.maxshield){ this.shield = this.maxshield; }			
			if ((this.deadtime < 0) && (this.hp == -1000)){
				this.respawn(theplanets[this.parentid]); //maybe change how I handle this
				}
			}
			updatebomb(){ //Handles timer and explosions
			this.timer= this.timer -1;
			if (this.timer == 0){this.killbomb();}
			if (this.timer == 1){this.s = 100*this.boombuff;}
			if (this.timer == 2){this.s = 128*this.boombuff;}
			if (this.timer == 3){this.s = 120*this.boombuff;}
			if (this.timer == 4){this.s = 100*this.boombuff;}
			if (this.timer == 5){this.s = 75*this.boombuff;}
			if (this.timer == 6){this.s = 50*this.boombuff;}
			if (this.timer>6){
				this.s = 8; //Mostly redundant
				if (this.hp < 0){this.timer = 6;}
				}
			}
		killship(deathtime){ //Ship is dead, and respawns after deathtime frames.
			this.x = 1000000+ Math.random()*100000; //Dead ships are banished 
			this.y = 0;
			this.vx = 0;
			this.vy = 0;
			this.vd = 0;
			this.d = 0;
			this.deadtime = deathtime; //deadtime counts down to trigger respawn
			this.hp = -1000;
			}
		killbomb(){ 
			this.x = 1000000 + Math.random()*100000; //Dead ships are banished 
			this.y = 0;
			this.vx = 0;
			this.vy = 0;
			this.vd = 0;
			this.d = 0;
			this.s = 8;
			}
		setorbit(parentplanet, distance, direction, cw){ //cw = -1 or 1
			this.match(parentplanet); //set velocity and position equal
			this.x = this.x + (distance)*Math.cos(direction); //set relative
			this.y = this.y + (distance)*Math.sin(direction); //start location;
			var gravy = parentplanet.m*.0003 / (distance*distance);  //gMm/r^2, where m is 1;
			var orbitspeed = Math.sqrt(gravy*distance);  //a = v^2/r, a* r = v^2, v = sqrt(a*r)
			this.vx = this.vx + orbitspeed*Math.cos(direction + cw*Math.PI/2);
			this.vy = this.vy + orbitspeed*Math.sin(direction + cw*Math.PI/2);
			}
		respawn(parentplanet){
			var rdir = Math.random()*Math.PI*2; //random direction from planet
			var rdist = parentplanet.s+this.s+12+Math.random()*2*parentplanet.s; //random ish distance
			var rcw = Math.floor(Math.random()*2)*2 - 1; //random orbit direction (-1 or 1);
			this.setorbit(parentplanet, rdist, rdir, rcw);
			this.hp = this.maxhp;
			}
		launchbomb(thebomb, mag, time){ //This allows significant weapon customization in the function call. 
			thebomb.match(this);	// Mag is how hard the bomb is pushed, time is how long before the bomb detonates on it's own.
			thebomb.x = thebomb.x + (this.s+thebomb.s+4)*Math.cos(this.d);
			thebomb.y = thebomb.y + (this.s+thebomb.s+4)*Math.sin(this.d); 
			thebomb.timer = time;
			thebomb.hp = 1;
			thebomb.push(mag,this.d);
			}
		drawbeam(viewx, viewy, beamlength, beamwidth, beamcolor){  //Draws the lazor
			var x = this.x - viewx + canvas.width/2; //normally camera center being the player ship.
			var y = this.y - viewy + canvas.height/2;
			var beamstartx = x + (this.s+4)*Math.cos(this.d);
			var beamstarty = y + (this.s+4)*Math.sin(this.d); 
			var beamstopx = x + (this.s+4+beamlength)*Math.cos(this.d);
			var beamstopy = y + (this.s+4+beamlength)*Math.sin(this.d); 
			context.strokeStyle = beamcolor; //Now actual drawing of the things
			context.lineWidth = beamwidth;
			context.beginPath(); 
			context.moveTo(beamstartx, beamstarty); 
			context.lineTo(beamstopx, beamstopy);
			context.stroke();
		}
		beamcollide(beamlength, target){ //Returns 1 if the beam of length beamlength is touching target Umo.
		var collide = 0;
		if (this.distance(target) < (this.s+target.s+beamlength)){
			var deltad = this.d - this.directionof(target);
			if (deltad > Math.PI){deltad = deltad - 2*Math.PI;}
			if (deltad < -1*Math.PI){deltad = deltad + 2*Math.PI;}
			if ((deltad< Math.PI/2)&&(deltad>-1*Math.PI/2)){
				var m = Math.tan(this.d);
				var x1 = this.x;
				var y1 = this.y;
				var x2 = target.x;
				var y2 = target.y; 
				var dy =  m*(x2-x1)+y1-y2 
				var dist = Math.abs(dy/m);
				if (dist<target.s){
					collide = 1;
					}
				}
			}
		return collide;
		}
	}//end Umo class.//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
//////////////////////////////slashes because I want to see this spot easily//////////////////////////////////////////////////////////////////////////////////
/////////////////////////////Begin system class///////////////////////////////////////////////////////////////////////////////////////////////////////////////
class System{
	constructor(index, name, x, y){
	this.index = index; //integer identifying system 
	this.name = name; //name of system for display
	this.planets = []; //list of planets (to be generated)
	this.ships = []; //list of ships (to be generated)
	this.botbombs = []; //list of bombs used in system
	this.difficulty = 1; //Scales ship generation attributes
	}
	randomplanets(){
		var numplanets = Math.floor(Math.random()*16+2);//random number of planets, 2-17
		var orbitradius = 0; //randomized in the loop
		var planetsize = 0; //randomized in the loop
		this.planets.push( new Umo(0,0,Math.floor(Math.random()*3000+1000), "orange") ); //make the sun 
		this.planets[0].name = this.name; // Star name is same as system name
		var i=0;
		while (i<numplanets-1){
			i=i+1; //planets[0] is already the sun, so we can skip index 0;
			orbitradius = Math.floor( (Math.random()*Math.random()*250000) + 2000); //Minimum radius 2000, 1/r density factor
			planetsize = Math.floor( Math.random()*Math.random()*800 + Math.random()*100+100 ); //Minimum size 100, 
			this.planets.push( new Umo(0,0,planetsize, randcolor() ) );//this is where the planet gets added to the array
			this.planets[i].name = randname(4);//random 4 character name
			this.planets[i].setorbit(this.planets[0], orbitradius, Math.random()*6.28, 1);
			this.planets[i].parentid = 0; //establishes star (planet[0] as parent planet
			//this.randommoons(i);
			}
		}
	randommoons(index){//index is of planet
		var nummoons = Math.floor(Math.random()*planets[index].s/150 )//Planets < 150 in size have 0 chance of a moon, planet 300 in size has 50% chance of 1 moon, etc.
		var moonsize = 0; //randomized in loop
		var moonorbitr = 0;//randomized in loop
		var moonindex = 0; //set in loop
		i = nummoons;
		while (i>0){
			i=i-1;
			moonsize = Math.floor(Math.random()*this.planets[index].s/3+10);//radius is 10 plus up to 1/3 of parent planet
			moonorbitr = Math.floor(this.planets[index].s*(Math.random()*3+1.5)); //orbit radius is 1.5x parent planet radius + up to 3x parent planet radius
			moonindex = this.planets.length-1;
			this.planets.push( new Umo(0,0,moonsize, randcolor()) );
			this.planets[moonindex].name = randname(4);
			this.planets[moonindex].parentid = index;
			this.planets[moonindex].setorbit(this.planets[index],moonorbitr,Math.random()*6.28, 1);//orbit direction is 1, not random
			}
		}
	levelup(botindex,levels){//adds "levels" to make bots tougher
		var i = levels;
		while(i>0){
			i=i-1;
			var bonus = Math.floor(Math.random()*5);//Picks a number to select which bonus the bot gets
			if (bonus==0){ //extra health
				this.ships[botindex].maxhp = this.ships[botindex].maxhp+100;
				this.ships[botindex].hp = this.ships[botindex].hp+100;
				}
			if (bonus==1){ //extra shield
				this.ships[botindex].maxshield = this.ships[botindex].maxshield+50;
				ships[botindex].shield = ships[botindex].shield+50;
				}
			if (bonus==2){ //extra shield regen
				ships[botindex].shieldregen = ships[botindex].shieldregen+0.25;
				}			
			if (bonus==3){ //extra bomb damage
				botbombs[botindex-1].hurt = botbombs[botindex-1].hurt+8;
				}						
			if (bonus==4){ //extra bomb blast
				botbombs[botindex-1].boombuff = botbombs[botindex-1].boombuff+0.25;//I think botbombs needs -1 because it does not include a bomb for ships[0] (player)
				}			
			ships[botindex].level = ships[botindex].level+1;
			}
		}
	addrandomgang(planetindex, num,level){ //Adds a gang of enemy ships, level describes difficulty (not used yet)
		var gangsize = num;
		var gangcolor = randcolor();
		var gangparent = planetindex;
		var randomsides = Math.floor(Math.random()*8)*2+8; //randomized side number
		var randomplayerverts = randpolarpoly(randomsides, 0.25);//sides,  minimum radius
		normalizepoly(randomplayerverts);
		var gangpolytheta = randomplayerverts[0];
		var gangpolyradius = randomplayerverts[1];
		
		var i = gangsize;
		while (i>0){
			i=i-1;
			this.ships.push(new Umo(-600,32000,32,gangcolor));
			var botindex = this.ships.length-1;
			this.ships[botindex].parentid = gangparent; 
			this.ships[botindex].respawn(this.planets[this.ships[botindex].parentid]);
			this.ships[botindex].name = randname(5);
			this.ships[botindex].hp = 150;
			this.ships[botindex].maxhp = 150;
			this.ships[botindex].polytheta = gangpolytheta;
			this.ships[botindex].polyradius = gangpolyradius;
			this.botbombs.push( new Umo(0,0,0,"red"));
			this.levelup(botindex,level);
			}
		}
	}//end of system class////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Mission{
	constructor(missiontype, morigin, mtarget,mmessage,mreward,mstory){
		this.type = missiontype; //string indicating type of mission, such as "Assassinate", "Defend" or "Cargo"
		this.origin = morigin; //Starting point for a cargo mission, in positive integer planet index
		this.target = mtarget; //Target for mission, positive integer list for ship(s) or planet index.
		this.message = mmessage; //"Kill that guy", "Take cargo to that planet"
		this.reward = mreward; //How much money you get, 0 indicates mission no longer active
		this.storypath = mstory; //What storystate the mission leads to, 0 for no affect on storystate
		}
	check(theships,theplanets,theradio){ //Determines if mission is complete
		var complete = 0;
		if (this.type == "assassinate"){ //If the mission is to kill a guy
			if (theships[this.target].hp < 0){complete = 1;} //If the ship is dead, the mission is complete.  Doesnt work yet
			}
			
		else if (this.type == "cargo"){ //If the mission is to take cargo to a planet.  Works on last test.
			if ((theplanets[this.target].distance(ships[0])<500) && (theplanets[this.target].deltav(ships[0])<10)){
				complete = 1; //Requires that you get close, and get slow relative to target planet.
				}
			}
		else if (this.type == "courier"){ //If the mission is to take cargo to a ship.  Untested
			if ((theships[this.target].distance(theships[0])<500) && (theships[this.target].deltav(theships[0])<10)){
				complete = 1; //Requires that you get close, and get slow relative to target planet.
				}
			}
		if (complete == 1){
			playerradio.newmsg("Dudeman",this.type+" mission complete.  Keep doing my thing. Payment of "+this.reward+" has been deposited.",time);//newmsg(sndr, msg, thetime)
			var givenreward = this.reward; //Saves mission reward to be returned
			var givenstory = this.storypath;
			this.type = ""; //Resets to inactive values.
			this.origin = 0;
			this.target = 0;
			this.message = "No mission";
			this.reward = 0;
			this.storypath = 0;
			return [givenreward,givenstory];//Storypath will be 0 for non-story missions, nonzero values will set the story state of the player in main loop
			}
			else {return [0,0];}
		}
	}
	//////////////////Function tests
	let testsystem = new System(2,"thetestsystem");
	let playerradio = new Radio("Welcome to Umo Space.  Fight robots, make money, trade cargo (eventually), buy upgrades, and see the universe.");
	testsystem.randomplanets();
	let mission1 =  new Mission("cargo", 0, 11, "Deliver this cheesy burrito to a client on Mede.",500, 1);
	let mission2 =  new Mission("assassinate", 0, 6, "A nasty robot in earf orbit needs to be removed.",1500, 0);
	//constructor(missiontype, morigin, mtarget,mmessage,mreward)
////////Declarations//////////////////////////////////////////////////////////////////////////////////
////////This is basically the game world/////////////////////////////////////////////////////////////////
////////Player stuff///////////////////////////////////////////////////////////
////////Planets////////////////////////////////////////////////////////////////////////////////////////
function loadhomesystem(){
	let sun = new Umo(0, 0, 2048, "orange"); //planet initialization/////////////
	sun.name = "Sool";
	let murc = new Umo(0,8000,150,"brown");//initial position irrelevant
	murc.name = "Murc";
	murc.setorbit(sun, 8000, 0, 1);
	murc.parentid = 0;
	let vnus = new Umo(0,14000,280,"yellow");//2
	vnus.name = "Vnus";
	vnus.setorbit(sun, 14000, 0, 1);
	vnus.parentid = 0;
	let earf = new Umo(0, 20000, 320, "blue"); //3
	earf.setorbit(sun, 20000, 0, 1);
	earf.name = "Earf";
	earf.parentid = 0;
	let moon = new Umo(1000, 20000, 100, "white"); //4
	moon.name = "Moon";
	moon.setorbit(earf, 1000, 0, 1);
	moon.parentid = 3;
	let merz = new Umo(0, 32000, 220, "red");//5
	merz.name = "Merz";						
	merz.setorbit(sun, 32000, 0, 1);
	merz.parentid = 0;
	let fobz = new Umo(600,32000,32, "white");//6
	fobz.name = "Fobz";
	fobz.setorbit(merz, 600, 0, 1);
	fobz.parentid = 5;
	let deem = new Umo(-800,32000,32, "white");//7
	deem.name = "Deem";
	deem.setorbit(merz, 800, 0, 1);
	deem.parentid = 5;
	let jupe = new Umo(0,0,1024,"brown");//8
	jupe.name = "Jupe";
	jupe.setorbit(sun,80000,0,1);
	jupe.parentid = 0;
	let heyo = new Umo(0,0,120,"yellow");//9
	heyo.name = "Heyo";
	heyo.setorbit(jupe,1280,0,1);
	heyo.parentid = 8;
	let erpa = new Umo(0,0,200,"blue");//10
	erpa.name = "Erpa";
	erpa.setorbit(jupe,3600,0,1);
	erpa.parentid = 8;
	let mede = new Umo(0,0,280,"brown");//11
	mede.name = "Mede";
	mede.setorbit(jupe,5200,0,1);
	mede.parentid = 8;
	let isto = new Umo(0,0,280,"tan");//12
	isto.name = "Isto";
	isto.setorbit(jupe,7200,0,1);
	isto.parentid = 8;
	let tern = new Umo(0,0,750,"yellow");//13
	tern.name = "Tern";
	tern.setorbit(sun,130000,0,1);
	tern.parentid = 0;
	let thys  = new Umo(0,0,120,"grey");//14
	thys.name = "Thys";
	thys.setorbit(tern,1200,0,1);
	thys.parentid = 13;
	let dion  = new Umo(0,0,150,"grey");//15
	dion.name = "Dion";
	dion.setorbit(tern,1800,0,1);
	dion.parentid = 13;
	let raya  = new Umo(0,0,200,"grey");//16
	raya.name = "Raya";
	raya.setorbit(tern,2400,0,1);
	raya.parentid = 13;
	let itan  = new Umo(0,0,300,"grey");//17
	itan.name = "Itan";
	itan.setorbit(tern,3600,0,1);
	itan.parentid = 13;
	let peet  = new Umo(0,0,200,"grey");//18
	peet.name = "Peet";
	peet.setorbit(tern,5600,0,1);
	peet.parentid = 13;
	let anus = new Umo(0,0,500,"green");//19
	anus.name = "Anus";
	anus.setorbit(sun,170000,0,1);
	anus.parentid = 0;
	let aril  = new Umo(0,0,150,"grey");//20
	aril.name = "Aril";
	aril.setorbit(anus,1000,0,1);
	aril.parentid = 19;		
	let umbi  = new Umo(0,0,150,"grey");//21
	umbi.name = "Umbi";
	umbi.setorbit(anus,1500,0,1);
	umbi.parentid = 19;				
	let titi  = new Umo(0,0,200,"grey");//22
	titi.name = "Titi";
	titi.setorbit(anus,2400,0,1);
	titi.parentid = 19;			
	let bron  = new Umo(0,0,200,"grey");//23
	bron.name = "Bron";
	bron.setorbit(anus,3000,0,1);
	bron.parentid = 19;		
	let tune = new Umo(0,0,550,"cyan");//24
	tune.name = "Tune";
	tune.setorbit(sun,210000,0,1);
	tune.parentid = 0;
	let tron = new Umo(0,0,250,"cyan");//25
	tron.name = "Tron";
	tron.setorbit(tune,1500,0,1);
	tron.parentid = 24;
	let homeplanets = [sun,murc,vnus,earf,moon,merz,fobz,deem,jupe,heyo,erpa,mede,isto,tern,thys,dion,raya,itan,peet,anus,aril,umbi,titi,bron,tune,tron];
	return homeplanets;
	}
let planets = loadhomesystem();
	//let planets = testsystem.planets; //basically works, but not ready.
////////Initialize Player//////////////////////////////////////////////////////////
let testship = new Umo (0,0,32,"black");//Used for calculations
let player1 = new Umo(400,32400,32,randcolor());//player ship
player1.hp = 1000; //1000 health,
player1.maxhp = 1000;//1000 maximum health
player1.parentid = 3; //Spawn relative to planet index 3.
player1.maxshield = 200; //Shield strength can be modified per ship
player1.shield = 200;
randomsides = Math.floor(Math.random()*8)*2+8; //randomized side number
randomplayerverts = randpolarpoly(randomsides, 0.25);//sides,  minimum radius
normalizepoly(randomplayerverts); //Makes the ship have at least 2 vertices at maximum radius (1).
player1.polytheta = randomplayerverts[0];//Assigns randomized polygon
player1.polyradius = randomplayerverts[1]; //to player1 ship
player1.setorbit(planets[5], 600, 3, -1); 
var ships = [player1];
///////Special Station Umos//////////////////////////////////////////////////////////////////////////////
let terranoutpost = new Umo (0,0,128, randcolor());
terranoutpost.parentid = 0;
terranoutpost.name = "Bill's Billion Bits";
var totheta = [Math.PI/4,3*Math.PI/4,5*Math.PI/4,7*Math.PI/4];
var toradii = [1,1,1,1]; //rectangle
terranoutpost.polytheta = totheta;
terranoutpost.polyradius = toradii;
terranoutpost.setorbit(planets[0], 20000, 0.25, 1);//set in orbit around sun behind earf 

let merzoutpost = new Umo(0,0,128, randcolor());
merzoutpost.parentid = 0;
merzoutpost.name = "The Merry Merzian";
var totheta = [Math.PI/4,3*Math.PI/4,5*Math.PI/4,7*Math.PI/4];
var toradii = [1,1,1,1]; //rectangle
merzoutpost.polytheta = totheta;
merzoutpost.polyradius = toradii;
merzoutpost.setorbit(planets[0], 32000, 0.2, 1);//set in orbit around sun behind merz

let jupeoutpost = new Umo(0,0,128, randcolor());
jupeoutpost.parentid = 0;
jupeoutpost.name = "Jojo's House of Cheese";
var totheta = [Math.PI/4,3*Math.PI/4,5*Math.PI/4,7*Math.PI/4];
var toradii = [1,1,1,1]; //rectangle
jupeoutpost.polytheta = totheta;
jupeoutpost.polyradius = toradii;
jupeoutpost.setorbit(planets[0], 80000, 0.1, 1);//set in orbit around sun behind jupe

let anusoutpost = new Umo(0,0,128, randcolor());
anusoutpost.parentid = 0;
anusoutpost.name = "Dangustown";
var totheta = [Math.PI/4,3*Math.PI/4,5*Math.PI/4,7*Math.PI/4];
var toradii = [1,1,1,1]; //rectangle
anusoutpost.polytheta = totheta;
anusoutpost.polyradius = toradii;
anusoutpost.setorbit(planets[0], 170000, 0.05, 1);//set in orbit around sun behind jupe

let outposts = [terranoutpost, merzoutpost, jupeoutpost, anusoutpost];
////////Player Bombs//////////////////////////////////////////////////////////////////////////////////////////       
function loadplayerbombs(){
	let p1b1 = new Umo(0,0,8,"red"); //Player weapon 1
	p1b1.c = "red"; //Staple player weapon
	p1b1.hurt = 16;
	p1b1.boombuff = 0.75;
	let p1b2 = new Umo(0,0,0,0); //Player weapon 2
	p1b2.c = "purple"; //Slow, powerful bomb
	p1b2.boombuff = 1.5;
	p1b2.hurt  = 64;
	let p1b3 = new Umo(0,0,0,0);  //Player weapon 3
	p1b3.c = "green"; //Weak short range flak weapon.		
	p1b3.boombuff = 1.2;
	p1b3.hurt = 12;
	let p1b4 = new Umo(0,0,0,0); //Player weapon 4
	p1b4.c = "blue"; //Fast, powerful, but costly projectile with minimal blast.		
	p1b4.boombuff = 0.2;
	p1b4.hurt = 50;
	let p1b50 = new Umo(0,0,0,0);//Weapon 5 will have 4 projectiles
	p1b50.c = "blue"; 		
	p1b50.boombuff = 0.5;
	p1b50.hurt = 12;
	let p1b51 = new Umo(0,0,0,0);
	p1b51.c = "blue"; 		
	p1b51.boombuff = 0.5;
	p1b51.hurt = 12;
	let p1b52 = new Umo(0,0,0,0);
	p1b52.c = "blue"; 		
	p1b52.boombuff = 0.5;
	p1b52.hurt = 12;
	let p1b53 = new Umo(0,0,0,0);
	p1b53.c = "blue"; 		
	p1b53.boombuff = 0.5;
	p1b53.hurt = 12;
	let p1b70 = new Umo(0,0,0,0);
	p1b70.c = "red"; 		
	p1b70.boombuff = 0.25;
	p1b70.hurt = 10;
	let p1b71 = new Umo(0,0,0,0);
	p1b71.c = "orange"; 		
	p1b71.boombuff = 0.25;
	p1b71.hurt = 10;
	let p1b72 = new Umo(0,0,0,0);
	p1b72.c = "yellow"; 		
	p1b72.boombuff = 0.25;
	p1b72.hurt = 10;
	let p1b73 = new Umo(0,0,0,0);
	p1b73.c = "green"; 		
	p1b73.boombuff = 0.25;
	p1b73.hurt = 10;
	let p1b74 = new Umo(0,0,0,0);
	p1b74.c = "blue"; 		
	p1b74.boombuff = 0.25;
	p1b74.hurt = 10;
	let p1b75 = new Umo(0,0,0,0);
	p1b75.c = "purple"; 		
	p1b75.boombuff = 0.25;
	p1b75.hurt = 10;
	let p1b76 = new Umo(0,0,0,0);
	p1b76.c = "purple"; 		
	p1b76.boombuff = 0.25;
	p1b76.hurt = 10;
	let p1b77 = new Umo(0,0,0,0);
	p1b77.c = "blue"; 		
	p1b77.boombuff = 0.25;
	p1b77.hurt = 10;
	let p1b78 = new Umo(0,0,0,0);
	p1b78.c = "green"; 		
	p1b78.boombuff = 0.25;
	p1b78.hurt = 10;
	let p1b79 = new Umo(0,0,0,0);
	p1b79.c = "yellow"; 		
	p1b79.boombuff = 0.25;
	p1b79.hurt = 10;
	let p1b710 = new Umo(0,0,0,0);
	p1b710.c = "orange"; 		
	p1b710.boombuff = 0.25;
	p1b77.hurt = 10;
	let p1b711 = new Umo(0,0,0,0);
	p1b711.c = "red"; 		
	p1b711.boombuff = 0.25;
	p1b711.hurt = 10;
	let p1b80 = new Umo(0,0,0,0);//weapon 8 is a chain-fired blaster
	p1b80.c = "red"; 		
	p1b80.boombuff = 0.25;
	p1b80.hurt = 10;	
	let p1b81 = new Umo(0,0,0,0);
	p1b81.c = "orange"; 		
	p1b81.boombuff = 0.25;
	p1b81.hurt = 10;	
	let p1b82 = new Umo(0,0,0,0);
	p1b82.c = "yellow"; 		
	p1b82.boombuff = 0.25;
	p1b82.hurt = 10;	
	let p1b83 = new Umo(0,0,0,0);
	p1b83.c = "green"; 		
	p1b83.boombuff = 0.25;
	p1b83.hurt = 10;	
	let p1b84 = new Umo(0,0,0,0);
	p1b84.c = "blue"; 		
	p1b84.boombuff = 0.25;
	p1b84.hurt = 10;	
	let p1b85 = new Umo(0,0,0,0);
	p1b85.c = "purple"; 		
	p1b85.boombuff = 0.25;
	p1b85.hurt = 10;	
	let p1b9 = new Umo(0,0,0,0);
	p1b9.c = "purple"; 		
	p1b9.boombuff = 2;
	p1b9.hurt = 20;	
	let p1b10 = new Umo(0,0,0,0);
	p1b10.c = "purple"; 		
	p1b10.boombuff = 0;
	p1b10.hurt = 1;	
	let pbs = [p1b1,p1b2,p1b3,p1b4,p1b50,p1b51,p1b52,p1b53,p1b70,p1b71,p1b72,p1b73,p1b74,p1b75,p1b76,p1b77,p1b78,p1b79,p1b710,p1b711,p1b80,p1b81,p1b82,p1b83,p1b84,p1b85,p1b9,p1b10]; 
	return pbs;
	}
let playerbombs = loadplayerbombs();
var i = playerbombs.length;
while (i>0){  //For all player bombs, set them up as a bomb Umos.
	i=i-1;
	playerbombs[i].hp = 1;  //Set hitpoints to 1 so they explode on contact
	playerbombs[i].maxhp = 1; //with planets 
	playerbombs[i].shield=0;  
	} 
let home = new System(1,"Sool");
let botbombs=[];
home.planets = planets;
home.ships = ships;
home.botbombs = botbombs;
//////procedural bot ship generation//////////////////////////////////////////////////////////////////////////////////////////////////
home.addrandomgang(1,2,24);
home.addrandomgang(2,3,3);
home.addrandomgang(3,3,2);//no moon bots
home.addrandomgang(5,3,1);//no deem, fobz, jupe, or heyo bots
home.addrandomgang(10,3,4);
home.addrandomgang(11,4,6);
home.addrandomgang(12,3,5);
home.addrandomgang(14,2,7);
home.addrandomgang(15,4,9);
home.addrandomgang(16,4,10);
home.addrandomgang(17,4,8);
home.addrandomgang(18,2,11);
home.addrandomgang(21,2,6);
home.addrandomgang(22,2,6);
home.addrandomgang(23,4,4);//no tune bots
home.addrandomgang(25,5,16);
var i = home.botbombs.length;
while (i>0){  ////For all bot bombs, set them up as a bomb Umos.
	i=i-1;
	home.botbombs[i].hp = 1;  //Set hitpoints to 1 so they explode on contact
	home.botbombs[i].maxhp = 1; //with planets 
	home.botbombs[i].shield=0;  
	}

var clicktester = 0;

//////////////////GAME LOOP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////update function this is the game loop bruh///////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function update() {
	time = time + 1;
	context.fillStyle = "black";//Background is black
	context.fillRect(0, 0, canvas.width, canvas.height); //rectangle the size of the canvas.
	if (mapactive == 1){drawmap(planets,mapscale,canvas.width/2,canvas.height/2, ships[0].x, ships[0].y);}//centered map
	if (mapactive == 2){drawmap(planets,mapscale,200,canvas.height-150,ships[0].x, ships[0].y);
		context.fillStyle = "black";//Background is black
		context.fillRect(0, 0, canvas.width, canvas.height-300); //erase non-corner map area
		context.fillRect(400, canvas.height-300, canvas.width,canvas.height); //erase non-corner map area
		context.beginPath(); //Border of map rectangle
		context.rect(0,canvas.height-300,400,300); //2*this.s wide
		context.lineWidth = 4; 
		context.strokeStyle = "blue";
		context.stroke();	
		}
		//All the outpost in-loop stuff will be here for now...
		planets[0].gravitate(terranoutpost);
		planets[0].gravitate(merzoutpost);
		planets[0].gravitate(jupeoutpost);
		planets[0].gravitate(anusoutpost);
		terranoutpost.d = terranoutpost.directionof(planets[0]);
		merzoutpost.d = merzoutpost.directionof(planets[0]);
		jupeoutpost.d = jupeoutpost.directionof(planets[0]);
		anusoutpost.d = anusoutpost.directionof(planets[0]);//Station always points at sun, or maybe away from sun.
		terranoutpost.update1();
		merzoutpost.update1();
		jupeoutpost.update1();
		anusoutpost.update1();
		if (ships[0].distance(terranoutpost)<drawdistance+terranoutpost.s/2){ //if ships[i] is near
			terranoutpost.drawstation(ships[0].x,ships[0].y); //draw station from ship[0]'s view
			if (ships[0].distance(terranoutpost)<160){
				terranoutpost.dock(ships[0]);
				dockstate = 1;
				}		
			}
		if (ships[0].distance(merzoutpost)<drawdistance+merzoutpost.s/2){ //if ships[i] is near
			merzoutpost.drawstation(ships[0].x,ships[0].y); //draw station from ship[0]'s view
			if (ships[0].distance(merzoutpost)<160){
				merzoutpost.dock(ships[0]);
				dockstate = 2;
				}		
			}
		if (ships[0].distance(jupeoutpost)<drawdistance+jupeoutpost.s/2){ //if ships[i] is near
			jupeoutpost.drawstation(ships[0].x,ships[0].y); //draw station from ship[0]'s view
			if (ships[0].distance(jupeoutpost)<160){
				jupeoutpost.dock(ships[0]);
				dockstate = 3;
				}		
			}
		if (ships[0].distance(anusoutpost)<drawdistance+anusoutpost.s/2){ //if ships[i] is near
			anusoutpost.drawstation(ships[0].x,ships[0].y); //draw station from ship[0]'s view
			if (ships[0].distance(anusoutpost)<160){
				anusoutpost.dock(ships[0]);
				dockstate = 4;
				}		
			}
/////////////////Determine which planets are close enough to be "active", and activate relevant ships///////////////////////////////////////////////////
			var i = planets.length;
			while (i>0){//For all planets...
				i=i-1;
				var adist = ships[0].distance(planets[i]);
				if ((planets[i].active==1)&&(adist>20000)){//If planet is already active and far away 
					planets[i].active = 0; //deactivate
				}else if ((planets[i].active==0)&&(adist<10000)){//else if planet is inactive and close
					planets[i].active = 1; //activate
					}	
				}
			var i=ships.length; //draw ships and planets///////////////////////////////////
			while (i>0){ //for all ships,
				i=i-1;
				if (ships[0].distance(ships[i])<drawdistance+ships[i].s/2){ //if ships[i] is near
					ships[i].drawship(ships[0].x,ships[0].y); //draw ship from ship[0]'s view
					}
				}
			i = planets.length; 
			while (i>0){ //for all planets
				i=i-1;
				if (ships[0].distance(planets[i])<drawdistance+planets[i].s/2){ //if planets[i] is near
					planets[i].drawplanet(ships[0].x,ships[0].y); //draw planet from shop[0]'s view
					}
				}
			i = botbombs.length; //for all bot bombs
			while (i>0){
				i=i-1;
				if (ships[0].distance(botbombs[i])<drawdistance){ // if bombs[i] is near
					botbombs[i].drawbomb(ships[0].x,ships[0].y); //draw bomb from ship[0]'s view
					}
				}	
			i = playerbombs.length; //for all player bombs
			while (i>0){
				i=i-1;
				if (ships[0].distance(playerbombs[i])<drawdistance){ // if bombs[i] is near
					playerbombs[i].drawbomb(ships[0].x,ships[0].y); //draw bomb from ship[0]'s view
					}
				}					
			i = ships.length; //update section////////////////////////////////////////////////////////////
			while (i>0){ //update ships
				i=i-1;
				ships[i].updateship(planets);
				}
			i = planets.length; //update planets
			while (i>0){
				i=i-1;
				planets[i].update1();
				}
			i = botbombs.length; //update bot bombs
			while (i>0){
				i=i-1;
				botbombs[i].update1();
				botbombs[i].updatebomb();
				}	
			i = playerbombs.length; //update player bombs
			while (i>0){
				i=i-1;
				playerbombs[i].update1();
				playerbombs[i].updatebomb();
				}	
			if (thruster<100){thruster=thruster+1;} //External variable updates
			if (energy<100){energy = energy +1;}
			i=planets.length; //gravitate section////////////////////////////////////////////////////
			while (i>0){ //Planet on ships and bombs
				i=i-1;
				var j = ships.length;
				while (j>0){ //gravitate on each ship
					j=j-1;
					planets[i].gravitate(ships[j]);
					}
				j = botbombs.length;
				while (j>0){ //gravitate on each bot bomb
					j=j-1;
					planets[i].gravitate(botbombs[j]);
					}  
				j = playerbombs.length;
				while (j>0){ //gravitate on each player bomb
					j=j-1;
					planets[i].gravitate(playerbombs[j]);
					}  
				}
			var i = planets.length;
			while (i>1){//Planet on planet gravity
				i=i-1;
				planets[0].gravitate(planets[i]);//sun gravitates all
				if (planets[i].parentid>0){	planets[planets[i].parentid].gravitate(planets[i]); } //others only affected by parent
				}
////////////collisions/////////////////////////////////////////////////////
			var i = planets.length;
			var j = ships.length;
			var k = playerbombs.length;
			while (i>0){ //For all planets
				i=i-1;
				j = ships.length;
				while (j>0){ //For all ships to each planet
					j=j-1;
					planets[i].circlecollide(ships[j]);
					}
				k = playerbombs.length;
				while (k>0){ //For all bombs to each planet
					k=k-1;
					planets[i].circlecollide(playerbombs[k]); 
					}
				k = botbombs.length;
				while (k>0){ //For all bombs to each planet
					k=k-1; 
					planets[i].circlecollide(botbombs[k]);
					}
				}
			j = ships.length;
			k = playerbombs.length;
			while (j>0){ //for all ships...
				j=j-1;
				k = playerbombs.length;
				while (k>0){
					k=k-1;
					if (ships[j].hp>=0){//do not execute on dead ships.  Maybe check player distance too.
						playerbombs[k].bombcollide(ships[j]);
						if (ships[j].hp<0){
							var getcash = Math.floor(Math.random()*21+10)*ships[j].level;
							money = money + getcash;
							gotmoney = [30,getcash];
							}//Doesn't handle death, just cash.
						}
					}	
				k = botbombs.length;
				while (k>0){
					k=k-1;
					if (ships[j].hp>=0){//do not execute on dead ships.  Maybe check player distance too.
						botbombs[k].bombcollide(ships[j]);
						if (ships[j].hp<0){
							var getcash = Math.floor(Math.random()*21+10);
							//money = money + getcash;//disabled bot kill payouts for now
							//gotmoney = [30,getcash];
							}//Doesn't handle death, just cash.
						}
					}	
				}
////////////AI behavior section///////////////////////////////////////////////
			var j = ships.length; 
			while (j>1){ //Does not act on ship[0], which is player1.  This means botbomb length is 1 less than ships.  Index must be adjusted accordingly
				j=j-1; 
				if ( (  ships[j].distance(planets[ships[j].parentid]) > 4000  )&&(ships[j].hp>0) ){//If this bot got lost....
					var savedhp = ships[j].hp; //remember it's hitpoints... 
					ships[j].respawn(planets[ships[j].parentid]); //Respawn...
					ships[j].hp = savedhp; //re-apply hitpoints so it doesn't get a free heal out of it.
					}
				if (ships[0].distance(ships[j]) < 5000){ //Don't do anything if player is far
					ships[j].track(ships[0]); //Bots point towards player
					if ((Math.random()>0.96) && (botbombs[j-1].timer < 1)){  //Bots fire occasionally, if bomb isn't out
						ships[j].launchbomb(botbombs[j-1], 12, 80); //12 pixels per frame, 80 frames.					
						}
					}
				}
///////Respawn handling////////////////////////////////////////////////////////////////////////////////////////////
			j = ships.length;
			while (j>0){
				j = j - 1;
				if ((ships[j].deadtime < 0) && (ships[j].hp == -1000)){ //Death is handled in the update1
					ships[j].respawn(planets[ships[j].parentid]); 
					}
				}
//////////Mouse turning/////////////////////////////////
			ships[0].d = moused+Math.PI; //Instant turning because its easy for now
//HUD information/////////////////////////////////////////////////////////////////////////////////////
//pointingat test///pointingat(objdir,dir,distance,size)
		var pointingtest = pointingat(ships[0].directionof(planets[3]), ships[0].d, ships[0].distance(planets[3]),planets[3].s)
///////////////Targeting HUD////////////////////////////////////////////////////////////////////////////////////////////////
			context.font='12px Arial';
			context.fillStyle = "white"; 
			var shipsinrange = [];//To help guide what ships are targetable by the player, I'm generating a short list / shallow copy of nearby ships.
			var radarrange = 5000;//Defines distance a ship can be from the player and still be targetable
			var closestdistance = 999999;//needs to be larger than radarrange 
			var closestindex = 0; //defaults to self-targeting if no ships in range
			var i=0;//Excludes player ship
			while (i<ships.length-1){ //this loop makes the short list
				i=i+1;
				var tdistance = Math.floor(ships[0].distance(ships[i]));
				if (tdistance<radarrange){shipsinrange.push([ships[i],tdistance,i]);}//shallow-copy ship into shipsinrange, with global index for reference [theship,distance,index]
				}
			var i=0;
			while (i<shipsinrange.length){//this loop finds the closest ship
				if (shipsinrange[i][1]<closestdistance){
					closestdistance = shipsinrange[i][1];//tracks closest distance,
					//closestindex = shipsinrange[i][2]; //and the global index (as in ships[index]) of the closest ship
					closestindex = i;					
					}
				i=i+1;
				}
			if (nmeactive == 1){//if targeting computer is on...
				var i=0;
				var nmechartnames = [];
				var nmechartdistances = [];
				while (i<shipsinrange.length){
					var shipname = shipsinrange[i][0].name;
					var shipdistance = shipsinrange[i][1];
					nmechartnames.push(shipname);
					nmechartdistances.push(shipdistance);
					i=i+1;
					}
				var nmechart1 = [nmechartnames,nmechartdistances];//maybe sort this by distance some day.
				//var cxytest = [ ["first", "column", "of", "words"], ["2nd", "column", "of", "words"]       ];
				targetchart(shipsinrange,64,16,canvas.width-300,16);
				//showchart(nmechart1, 64, 16, canvas.width-300,10);//test location
				if (shipsinrange.length == 0){
					context.font = '20px Ariel';
					context.fillStyle = "red";
					context.fillText("No targets in range", canvas.width-160, 24);
					}
				}
			if (shiptarget>shipsinrange.length-1){shiptarget = closestindex;}
			if (shipsinrange.length>0){
				//shipsinrange[shiptarget][0].drawcompass(ships[0],canvas.width-64, 96, 64); //Targeting computer compass
				ships[0].drawcompass2(shipsinrange[shiptarget][0],canvas.width-64, 96, 64); //Targeting computer compass
				shipsinrange[shiptarget][0].drawreticle(ships[0].x,ships[0].y); //Targeting reticle
				var nmechart2 = [["Name","Level","HP","Shield","Damage","Blast","Regen"],[shipsinrange[shiptarget][0].name, shipsinrange[shiptarget][0].level, shipsinrange[shiptarget][0].hp,  shipsinrange[shiptarget][0].shield,  botbombs[shipsinrange[shiptarget][2]-1].hurt, botbombs[shipsinrange[shiptarget][2]-1].boombuff,shipsinrange[shiptarget][0].shieldregen]];
				showchart(nmechart2, 64, 16, canvas.width-128,192);//test location
				context.beginPath(); 
				context.rect(canvas.width-304,4+16*shiptarget, 160, 16); //This is the item selection indicator
				context.lineWidth = 2; 
				context.strokeStyle = "white";
				context.stroke();	
				}
			//targetchart(shipsinrange,64,16,canvas.width-200,700);
			//maybe causeing the graphical problems?
			//drawaskey(canvas.width-324,32,"[","white");
			//drawaskey(canvas.width-324,64,"]","white");
			//drawaskey(canvas.width-324,96,"T","white");
			//drawaskey(32,canvas.height-320,"+","white");
			//drawaskey(64,canvas.height-320,"-","white");
			//drawaskey(96,canvas.height-320,"M","white");
			//drawaskey(canvas.width-32,canvas.height-200,">","white");
			//drawaskey(canvas.width-64,canvas.height-200,"<","white");
			//drawaskey(canvas.width-96,canvas.height-200,"N","white");
///////////////Navigation hud///////////////////////////////////////////////////////////////////////////////////////////////////////////
		if (navactive > 0){
			var thenavtarget=0;
			if (navactive==1){thenavtarget=planets[navtarget];}
			if (navactive==2){thenavtarget=outposts[navtarget];}
			thenavtarget.drawcompass(ships[0],canvas.width-64,canvas.height-96, 64); //Nav computer compass for planets
			var solardistance = planets[0].distance(ships[0]); //distance to sun
			var solargravity = (.0003*planets[0].m)/(solardistance*solardistance); //Gravitational influence of sun, pixels per frame per frame.
			var distance = thenavtarget.distance(ships[0]); //distance to target planet
			var planetarygravity = (.0003*thenavtarget.m)/(distance*distance); //gravity from target planet

			var name = thenavtarget.name;
			var pclass = "Moon"; //Defaults to Moon,
			if (navtarget==0){pclass = "Star";} //0 index is the sun
			else if (thenavtarget.parentid == 0){pclass = "Planet";}//Objects orbiting sun are planets
			var size = String(Math.floor(thenavtarget.s));
			var mass = String(Math.floor(thenavtarget.m/1000));
			var parent = planets[thenavtarget.parentid].name;	
			var orbitradius = thenavtarget.distance(planets[thenavtarget.parentid]);
			var orbitspeed = thenavtarget.deltav(planets[thenavtarget.parentid]);
			var orbitpos = planets[thenavtarget.parentid].directionof(thenavtarget);
			while (orbitpos > Math.PI){orbitpos=orbitpos - 2*Math.PI;} //This reduces the angle difference to within +- Math.PI
			while (orbitpos < -1*Math.PI){orbitpos = orbitpos + 2*Math.PI;}
			var distance = thenavtarget.distance(ships[0]); //distance to target planet
			//var planetarygravity = (.0003*planets[navtarget].m)/(distance*distance); //gravity from target planet
			var gravity = ((.0003*thenavtarget.m*900)/(distance*distance)).toFixed(3);
			var dv = thenavtarget.deltav2(ships[0]);
			var deltav = (dv[0]).toFixed(3).padStart(8,"0");
			var cosdv =  Math.cos(dv[1]-ships[0].directionof(thenavtarget))*dv[0];
			var sindv =  Math.sin(dv[1]-ships[0].directionof(thenavtarget))*dv[0];
			var escape = Math.sqrt(thenavtarget.m*2*.0003/ships[0].distance(thenavtarget));
			var navchart2 = [ ["Name","Class", "Size", "Mass", "Parent", "Orbit Radius", "Orbit speed", "Orbit Position"], [name, pclass, size, mass, parent, Math.floor(orbitradius), Math.floor(orbitspeed), orbitpos.toFixed(3)],  ["Distance","DeltaV", "Cos DV", "Sin DV", "Gravity", "Escape","X","Y"], [Math.floor(distance),deltav, cosdv.toFixed(3), sindv.toFixed(3), gravity, escape.toFixed(3),Math.floor(planets[navtarget].x), Math.floor(planets[navtarget].y)]  ];
			showchart(navchart2, 80, 16, canvas.width-500,canvas.height-160);	
			}
			context.fillText("Press N key to cycle navigation computer mode",canvas.width-300,canvas.height-8);
////////////////////////Map/////////////////////////////////////
			//if (mapactive == 1){drawmap(planets,256,canvas.width/2,canvas.height/2, ships[0].x, ships[0].y);}
			//planets[0].drawcompass(ships[0],canvas.width/2,canvas.height-48); //Nav computer compass for sun
///////////////Rest of HUD/////////////////////////////////////////////////////////////////////////////////////////////////	
	context.font='12px Arial';
	context.fillStyle = "orange"; //thruster power bar 
    context.fillRect(4, 64,Math.floor(0.64*thruster), 16);
	context.fillStyle = "red"; //weapons energy bar
    context.fillRect(4, 44,Math.floor(0.64*energy), 16);
	context.fillStyle = "blue"; //shield bar
    context.fillRect(4, 24,Math.floor(64*ships[0].shield/ships[0].maxshield), 16);
	context.fillStyle = "green"; //health bar
    context.fillRect(4, 4,Math.floor(64*ships[0].hp/ships[0].maxhp), 16);
	context.fillStyle = "white";
	var statuschart1 = [ ["Health","Shields", "Weapons", "Thrusters"]  ];
	showchart(statuschart1, 80, 20, 8,16);	
	context.fillText("Money",5,90);
	context.fillText(money,50,90);
	if (gotmoney[0]>0){
		gotmoney[0] = gotmoney[0]-1;
		context.fillStyle = "green";
		context.fillText("+"+gotmoney[1],100,90);
		context.fillStyle = "white";
		}
	context.fillText("Active Weapon:",8,110);
	context.fillText(wep,32,144);
	context.fillText("Mouse aims, left-flick fires, right-click thrusts, 1234567890 selects weapons. M toggles map mode, N toggles nav computer mode, < and > cycles nav targets, [ and ] cycles enemy targets, T for closest target (sometimes)",128,10);

	if (ships[0].hp==-1000){
	context.fillStyle = "red";
	context.font='24px Arial';
	context.fillText("You ded bruh."+ships[0].deadtime,canvas.width/2,canvas.height/2);
	context.fillStyle = "white";
	context.font='12px Arial';
	}
	context.fillStyle = "white";
	context.font='12px Arial';
	//context.fillText(mousestate,5,250);//tests and stuff
	//context.fillText(storystate,5,500);//tests and stuff
	playerradio.display(time);
////Shopping!//////////////////////////////////////////////////////
if (dockstate==1){//Earf station
	context.fillText("Up and Down to select, Enter to purchase.",canvas.width/2+64,canvas.height/2-120);
	var shopchart1 = [ ["$20 Repair hull", "$200 w3 Flakker", "$600 w1 Blaster Upgrade I (detonator)","$1000 w3 Flakker Upgrade I (damage)","$1000 w6 Laser","$800 Single-use extra hull","EMPTY","EMPTY","EMPTY","EMPTY"]  ];
	context.font='12px Arial';
	context.fillStyle = "white";
	showchart(shopchart1, 80,20,canvas.width/2+64, canvas.height/2-90);	
	context.fillText(shopitem,canvas.width/2+64,canvas.height/2+120);	
	context.beginPath(); 
	context.rect(canvas.width/2+60,canvas.height/2-104+20*shopitem, 256, 18); //This is the item selection indicator
	context.lineWidth = 2; 
	context.strokeStyle = "green";
	context.stroke();	
	}
if (dockstate==2){//Merz station
	context.fillText("Up and Down to select, Enter to purchase.",canvas.width/2+64,canvas.height/2-120);
	var shopchart1 = [ ["$20 Repair hull","$400 w2 Mine", "$200 w3 Flakker", "$600 w1 Blaster Upgrade I (detonator)","$1000 Armor Upgrade I","$3000 Radar Upgrade I","$400 Single-use extra hull","EMPTY","EMPTY","EMPTY"]  ];
	context.font='12px Arial';
	context.fillStyle = "white";
	showchart(shopchart1, 80,20,canvas.width/2+64, canvas.height/2-90);	
	context.fillText(shopitem,canvas.width/2+64,canvas.height/2+120);	
	context.beginPath(); 
	context.rect(canvas.width/2+60,canvas.height/2-104+20*shopitem, 256, 18); //This is the item selection indicator
	context.lineWidth = 2; 
	context.strokeStyle = "green";
	context.stroke();	
	}
if (dockstate==3){//Jupe station
	context.fillText("Up and Down to select, Enter to purchase.",canvas.width/2+64,canvas.height/2-120);
	var shopchart1 = [ ["$20 Repair hull","$400 w2 Mine", "$200 w3 Flakker", "$1000 w4 Railgun","$600 w1 Blaster Upgrade I (detonator)","$1200 w2 Mine Upgrade I (detonator)","$1000 w3 Flakker Upgrade I (damage)","$1000 Armor Upgrade I","$2000 Shield Upgrade I","$800 Single-use extra hull"]  ];
	context.font='12px Arial';
	context.fillStyle = "white";
	showchart(shopchart1, 80,20,canvas.width/2+64, canvas.height/2-90);	
	context.fillText(shopitem,canvas.width/2+64,canvas.height/2+120);	
	context.beginPath(); 
	context.rect(canvas.width/2+60,canvas.height/2-104+20*shopitem, 256, 18); //This is the item selection indicator
	context.lineWidth = 2; 
	context.strokeStyle = "green";
	context.stroke();	
	}
if (dockstate==4){//Anus station
	context.fillText("Up and Down to select, Enter to purchase.",canvas.width/2+64,canvas.height/2-120);
	var shopchart1 = [ ["$20 Repair hull","$1000 w4 Railgun","$2400 w5 SpreadShot Cannon","$4000 w6 Lazzor","$6000 w7 Double Rainbow","$4000 w8 Spectral Disintegrator", "$10000 w9 Bapadoop","$2000 Shield Upgrade I","$400 Single-use extra hull","EMPTY"]  ];
	context.font='12px Arial';
	context.fillStyle = "white";
	showchart(shopchart1, 80,20,canvas.width/2+64, canvas.height/2-90);	
	context.fillText(shopitem,canvas.width/2+64,canvas.height/2+120);	
	context.beginPath(); 
	context.rect(canvas.width/2+60,canvas.height/2-104+20*shopitem, 256, 18); //This is the item selection indicator
	context.lineWidth = 2; 
	context.strokeStyle = "green";
	context.stroke();	
	}
//////////////////////////////////Weapon 8 in-loop code, its special like that////////////////////////////////////////////////////////////////////////////////////
//Now here i'm kludging rapid fire with 6 w8 bombs.  It worked.
if((mousestate==1)&&(time%4==0)&&(wep==8)&&(energy>6)){
	var n = Math.floor(time/4)%6;
	ships[0].launchbomb(playerbombs[20+n],16,16);//A mere 1 pixel per frame, but for 600 frames (20s).
	energy = energy - 6;
	}
///////weapon 10 in-loop code, probe is special//////////////////////////////////////////////////
if (wep==0){//wep == 11 to disable, wep should ==0
	var j = ships.length;
	while (j>1){ //for all ships...
		j=j-1;
		if (playerbombs[27].collide(ships[j]));//Checks for collision only
			ships[0].polytheta = ships[j].polytheta;//Applies enemy polygon to player
			ships[0].polyradius = ships[j].polyradius;
			}
		}
//////////////////////Time Triggers//////////////////////////////////////////////////////////////////////
if (time==300){
playerradio.newmsg("Dudeman",mission1.message,time);//newmsg(sndr, msg, thetime)
}
if (time==500){
playerradio.newmsg("Dudeman",mission2.message+ships[mission2.target].name,time);//newmsg(sndr, msg, thetime)
}
//Mission checks///////////////////////////////////////////////////////////////////
var completemission1 = mission1.check(ships,planets,playerradio); //Saves mission reward money to variable if mission is completed, check function also modifies storystate
money = money + completemission1[0];
if (completemission1[1]>0){storystate=completemission1[1];}
//
////////////////////////////////////////////////////////Keyboard input/////////////////////////////////////
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return; // Do nothing if the event was already processed
  }
  switch (event.key) {  //events for all the keyboard keys
    case " ":
      ships[0].thrust = 2*thrustmultiplier; //pushes player in direction this.d
      break;   
	case "z": //sort of a secret feature, might become an upgrade later
		if (thrustmultiplier < 2){ thrustmultiplier = thrustmultiplier + .25; }
		else { thrustmultiplier = 0.25; }
      break;
	case "a": //Not really used
		if (launchmultiplier < 2){ launchmultiplier = launchmultiplier + .25; }
		else {	launchmultiplier = 0; }
      break;	  
	case "1":    //This is how weapon switching is handled.
		if (w1>0){ wep = 1; } //If weapon is present, switch to it.		
		break; //Nothing happens on keypress otherwise.
	case "2": 
		if (w2>0){ wep = 2; }
	  break;
	case "3": 
		if (w3>0){ wep = 3; }
      	break;
	case "4": 
		if (w4>0){ wep = 4; }
   	 break;
	case "5": 
		if (w5>0){ wep = 5; }
	  break;
	case "6": 
		if (w6>0){ wep = 6; }
   	   break;
	case "7": 
		if (w7>0){ wep = 7; }
	  break;
	case "8": 
		if (w8>0){ wep = 8; }
 	     break;
	case "9": 
		if (w9>0){ wep = 9; }
	  break;
	case "0": 
		if (w0>0){ wep = 0; }
     	 break;
	case "n": 
		if (navactive == 0){
			navactive = 1;
			if (navtarget>planets.length-1){navtarget=0;}
		} else if (navactive == 1) {
			navactive = 2;
			if (navtarget > outposts.length-1){navtarget=0;}
		} else if (navactive == 2){navactive = 0;}
    	  break;
	case "m": 
		if (mapactive == 0){mapactive = 2;} else {mapactive = mapactive-1;}
    	  break;
	case "+": 
		mapscale = mapscale * 0.9;
		if (mapscale>64){mapscale = Math.floor(mapscale);}
    	  break;		  
	case "-": 
		mapscale = mapscale * 1.1;
		if (mapscale>64){mapscale = Math.floor(mapscale);}
    	  break;	  
	case ".": 
			if (navactive == 1){
				navtarget = navtarget+1;
				if (navtarget == planets.length){ navtarget = 0; }
			}else if (navactive == 2){
				navtarget = navtarget+1;
				if (navtarget == outposts.length){navtarget = 0; }
				}
    	  break;
	case ",": 
		if (navactive == 1){
			navtarget = navtarget-1;
			if (navtarget == -1){ navtarget = planets.length-1; }
		}else if (navactive == 2){
			navtarget = navtarget-1;
			if (navtarget == -1){ navtarget = outposts.length-1; }
			}
		break;		  
	case "w": 
		ships[0].respawn(planets[navtarget]);
     	 break;
	case "]": 
		if (shiptarget == shipsinrange.length-1){ shiptarget = 0; }
		else {shiptarget = shiptarget+1;}	                                          
      break;
	case "[": 
		if (shiptarget == 0){ shiptarget = shipsinrange.length-1; }
		else {shiptarget = shiptarget-1;}	                                          
      break;
	case "t": 
		shiptarget = closestindex;                                         
      break;
    case "ArrowUp":
		shopitem = shopitem - 1;
		if (shopitem<0){shopitem = 9;}
      break;
    case "ArrowDown":
		shopitem = shopitem + 1;
		if (shopitem>9){shopitem = 0;}
      break;   //handled in detail elsewhere
	case "s":
		if (shop == 0){shop = 1;} else {shop = 0;}
      break;
	 case "Enter": //Most of the functional shopping code goes here.
		if (dockstate == 1){//Only works in shop 1, Earf station
			if ((shopitem == 0)&&(money>19)){ //First item on list
				ships[0].hp = ships[0].maxhp;
				money = money - 20;
			}else if ((shopitem == 1)&&(money>199)){//3rd item is w3
				if (w3 == 0){//Only buy if not already bought
					w3 = 1; //Flakker is weapon 3
					money = money - 200;
					}
			}else if ((shopitem == 2)&&(money>599)){
				if (w1 == 1){//Only buy if w1 present but not upgraded
					w1 = 2; //Values >1 denote upgrades.
					money = money - 600;
					}
			}else if ((shopitem == 3)&&(money>999)){
				if (w3 == 1){//Only buy if w3 present but not upgraded
					w3 = 2; //Values >1 denote upgrades.
					bombs[2].hurt = bombs[2].hurt + 20; //bombs index 2 is player weapon 3
					money = money - 1000;
					}
			}else if ((shopitem == 4)&&(money>999)){
				if (w6 == 0){//Only buy if a1 has no upgrades
					w6 = 1; //Values >1 denote further upgrades.
					money = money - 1000;
					}
			}else if ((shopitem == 5)&&(money>799)){
				ships[0].hp = 2 * ships[0].maxhp;  //Adds hit points beyond maximum -- can't repair it!
				}
			}//end of shop 1 handling
//	var shopchart1 = [ ["$20 Repair hull","$400 w2 Mine", "$200 w3 Flakker", "$600 w1 Blaster Upgrade I (detonator)","$1000 Armor Upgrade I","$3000 Radar Upgrade I","$400 Single-use extra hull","EMPTY","EMPTY","EMPTY"]  ];
		if (dockstate == 2){//Only works in shop 2, Merz's station
			if ((shopitem == 0)&&(money>19)){ //First item on list is repair job
				ships[0].hp = ships[0].maxhp;//repair 
				money = money - 20;//bill
			}else if ((shopitem == 1)&&(money>399)){ //Second item...
				if (w2 == 0){//Only buy if not already bought
					w2 = 1; 
					money = money - 400;
					}
			}else if ((shopitem == 2)&&(money>199)){
				if (w3 == 0){//Only buy if not already bought
					w3 = 1; //Flakker is weapon 3
					money = money - 200;
					}
			}else if ((shopitem == 3)&&(money>599)){//upgrade blaster
				if (w1 == 1){//Only buy if w1 present but not upgraded
					w1 = 2; //Values >1 denote upgrades.
					money = money - 600;
					}
			}else if ((shopitem == 4)&&(money>999)){
				if (a1 == 0){//Only buy if a1 has no upgrades
					a1 = 1; //Values >1 denote further upgrades.
					ships[0].maxhp = ships[0].maxhp + 250; //bombs index 2 is player weapon 3
					money = money - 1000;
					}
			}else if ((shopitem == 5)&&(money>2999)){
				if (radarrange == 4000){//Only buy if radar has no upgrades
					radarrange = 6000;
					money = money - 3000;
					}
			}else if ((shopitem == 6)&&(money>799)){
				ships[0].hp = 2 * ships[0].maxhp;  //Adds hit points beyond maximum -- can't repair it!
				money = money - 800;
				}
		}//end of shop 2 handling//////////////////////////////////////////////////////////////////////////////

		if (dockstate == 3){//Only works in shop 3, Jupe's station
			if ((shopitem == 0)&&(money>19)){ //First item on list
				ships[0].hp = ships[0].maxhp;
				money = money - 20;
			}else if ((shopitem == 1)&&(money>399)){ //Second item is weapon 2, a mine
				if (w2 == 0){//Only buy if not already bought
					w2 = 1; //enables weapon
					money = money - 400;
					}
			}else if ((shopitem == 2)&&(money>199)){//3rd item is w3
				if (w3 == 0){//Only buy if not already bought
					w3 = 1; //Flakker is weapon 3
					money = money - 200;
					}
			}else if ((shopitem == 3)&&(money>999)){
				if (w4 == 0){//Only buy if not already bought
					w4 = 1; //Railgun is w4
					money = money - 1000;
					}
			}else if ((shopitem == 4)&&(money>599)){
				if (w1 == 1){//Only buy if w1 present but not upgraded
					w1 = 2; //Values >1 denote upgrades.
					money = money - 600;
					}
			}else if ((shopitem == 5)&&(money>1199)){
				if (w2 == 1){//Only buy if w3 present but not upgraded
					w2 = 2; //Values >1 denote upgrades.
					money = money - 1200;
					}
			}else if ((shopitem == 6)&&(money>999)){
				if (w3 == 1){//Only buy if w3 present but not upgraded
					w3 = 2; //Values >1 denote upgrades.
					bombs[2].hurt = bombs[2].hurt + 20; //bombs index 2 is player weapon 3
					money = money - 1000;
					}
			}else if ((shopitem == 7)&&(money>999)){
				if (a1 == 0){//Only buy if a1 has no upgrades
					a1 = 1; //Values >1 denote further upgrades.
					ships[0].maxhp = ships[0].maxhp + 250; //bombs index 2 is player weapon 3
					money = money - 1000;
					}
			}else if ((shopitem == 8)&&(money>1999)){
				if (s1 == 0){//Only buy if s1 has no upgrades
					s1 = 1; //Values >1 denote further upgrades.
					ships[0].maxshield = ships[0].maxshield + 200; //Incrementing allows me to rebalance initial maximum
					money = money - 2000;  //Regen rate is unchanged, will be upgradable soon
					}
			}else if ((shopitem == 9)&&(money>799)){
				ships[0].hp = 2 * ships[0].maxhp;  //Adds hit points beyond maximum -- can't repair it!
				}
		}//end of shop 3 handling///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//[ ["$20 Repair hull","$1000 w4 Railgun","$2400 w5 SpreadShot Cannon","$4000 w6 Lazzor","$6000 w7 Double Rainbow","$4000 w8 Spectral Disintegrator", "$10000 w9 Bapadoop","$2000 Shield Upgrade I","$800 Single-use extra hull","EMPTY"]  ];
		if (dockstate == 4){//Only works in shop 4, Anus's station
			if ((shopitem == 0)&&(money>19)){ //First item on list
				ships[0].hp = ships[0].maxhp;
				money = money - 20;
			}else if ((shopitem == 1)&&(money>999)){ //Second item is weapon 4, railgun
				if (w4 == 0){//Only buy if not already bought
					w4 = 1; //enables weapon
					money = money - 1000;
					}
			}else if ((shopitem == 2)&&(money>2399)){//3rd item is w5, spreadcannon
				if (w5 == 0){//Only buy if not already bought
					w5 = 1;
					money = money - 2400;
					}
			}else if ((shopitem == 3)&&(money>3999)){//w6 lazzzor
				if (w6 == 0){//Only buy if not already bought
					w6 = 1; 
					money = money - 4000;
					}
			}else if ((shopitem == 4)&&(money>5999)){
				if (w7 == 0){//Only buy if w1 present but not upgraded
					w7 = 1; //Values >1 denote upgrades.
					money = money - 6000;
					}
			}else if ((shopitem == 5)&&(money>3999)){
				if (w8 == 0){//Only buy if w3 present but not upgraded
					w8 = 1; //Values >1 denote upgrades.
					money = money - 4000;
					}
			}else if ((shopitem == 6)&&(money>9999)){
				if (w9 == 0){//Only buy if w3 present but not upgraded
					w9 = 1; //Values >1 denote upgrades.
					money = money - 10000;
					}
			}else if ((shopitem == 7)&&(money>1999)){
				if (s1 == 0){//Only buy if a1 has no upgrades
					s1 = 1; //Values >1 denote further upgrades.
					ships[0].maxhp = ships[0].maxhp + 250; //bombs index 2 is player weapon 3
					money = money - 2000;
					}

			}else if ((shopitem == 8)&&(money>799)){
				ships[0].hp = 2 * ships[0].maxhp;  //Adds hit points beyond maximum -- can't repair it!
				money = money - 800;
				}
		}//end of shop 4 handling///////////////////////////////////////////////////////////////////////////////////////////////////////////////
      break;
    default:
      return; // Quit when this doesn't handle the key event.
  } //end event key handling switch
  event.preventDefault();// Cancel the default action to avoid it being handled twice
}, true);	//end of event key handling, not clear what the ", true);" is about		
}//end update function
document.addEventListener("mousemove", mouseMoveHandler, false);
function mouseMoveHandler(e) {
    var dx =  e.clientX - canvas.width/2;
	var dy =  e.clientY - canvas.height/2;
	moused = -1*Math.atan2(dx,dy) - Math.PI/2;
	mousedistance = Math.sqrt(dx*dx+dy*dy);
	//clicktester=clicktester+1;  //Apparently also fucked, but not normally a problem.
} //I should figure that out better.
document.addEventListener("mousedown", mouseDownHandler, false);
function mouseDownHandler(e) {
mousestate = e.buttons;
if (mousestate==1){ //if it's the left button
	if (wep == 1){
		if ((w1 > 1)&&(playerbombs[0].timer > 4)){playerbombs[0].timer = 6;} //This remote detonation code doesn't work with mousedown for some reason
		else if ((energy > 20)&&(w1>0)){ //If ship has energy and weapon 1.
			ships[0].launchbomb(playerbombs[0],12, 120);  //launch bomb[0] 12 pixels per frame, timed to explode in 120 frames.
			energy = energy - 20; //w1 costs 20 energy
			}
		}
	if (wep == 2){
		if ((w2 > 1)&&(playerbombs[1].timer > 4)){playerbombs[1].timer = 6;} 
		else if ((energy > 50)&&(w2>0)){ 
			ships[0].launchbomb(playerbombs[1],1, 600);//A mere 1 pixel per frame, but for 600 frames (20s).
			energy = energy - 50;
			}
		}
	if (wep == 3){
		 if ((energy > 30)&&(w3>0)){ //If ship has energy and weapon 3.
				ships[0].launchbomb(playerbombs[2],16, 12);
				energy = energy - 33;
			}
		}						
	if (wep == 4){
		if ((energy > 75)&&(w4>0)){ //If ship has energy and weapon 4.
				ships[0].launchbomb(playerbombs[3],24, 120);  
				energy = energy - 75; 
			}
		}
	if (wep == 5){
		if (energy > 40){ //If ship has energy
			var shipdsave = ships[0].d; 
			//var spread = 0.4;
			if (mousedistance>(canvas.width*0.6)){var spread = (Math.PI*0.75)/(canvas.width*0.6/32);}
			else if (mousedistance<32){var spread = (Math.PI*0.75)/(32/32);}
			else {var spread = (Math.PI*0.75)/(mousedistance/32);}
			ships[0].d = shipdsave - spread; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[4],12, 80); //launches 1st of four bombs
			ships[0].d = shipdsave - spread/3; //rotates to next position in spread...
			ships[0].launchbomb(playerbombs[5],12, 80);//launches next bomb...
			ships[0].d = shipdsave + spread/3;
			ships[0].launchbomb(playerbombs[6],12, 80);
			ships[0].d = shipdsave + spread;
			ships[0].launchbomb(playerbombs[7],12, 80);					
			ships[0].d = shipdsave;//restores original ship direction
			energy = energy - 40; 
			}
		}
	if (wep == 6){
		if (energy > 1){ //If ship has energy
			var i = ships.length;
			while (i>1){//For all ships except 0
				i = i - 1; 
				if (ships[0].distance(ships[i])<500){
					var ptest = pointingat(ships[0].directionof(ships[i]),ships[0].d,ships[0].distance(ships[i]),ships[i].s)
					if (ptest == 1){
						ships[i].damage(50);
						var x = ships[i].x - ships[0].x + canvas.width/2;
						var y = ships[i].y - ships[0].y + canvas.height/2;
						}
					//function pointingat(objdir,dir,distance,size){ //are you pointing at a thing?
					}
				}
			context.beginPath();
			context.moveTo(canvas.width/2, canvas.height/2);
			context.lineTo(canvas.width/2+Math.cos(ships[0].d)*500,canvas.height/2+Math.sin(ships[0].d)*500);
			context.strokeStyle = "red";
			context.stroke();	
			energy = energy - 30; 
			}
		}				
	
	if (wep == 7){
		if (energy > 60){ //If ship has energy
			var shipdsave = ships[0].d; 
			if (mousedistance>(canvas.width*0.6)){var spread = (Math.PI*0.25)/(canvas.width*0.6/32);}
			else if (mousedistance<32){var spread = (Math.PI*0.25)/(32/32);}
			else {var spread = (Math.PI*0.25)/(mousedistance/32);}
			ships[0].d = shipdsave - spread*5.5; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[8],24, 24); //launches 1st of four bombs
			ships[0].d = shipdsave - spread*4.5; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[9],24, 24); //launches 1st of four bombs
			ships[0].d = shipdsave - spread*3.5; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[10],24, 24); //launches 1st of four bombs
			ships[0].d = shipdsave - spread*2.5; //rotates to next position in spread...
			ships[0].launchbomb(playerbombs[11],24, 24);//launches next bomb...
			ships[0].d = shipdsave - spread*1.5; //Rotates the ship to accomodate launchbomb function
			ships[0].launchbomb(playerbombs[12],24, 24); //launches 1st of four bombs
			ships[0].d = shipdsave - spread/2; //rotates to next position in spread...
			ships[0].launchbomb(playerbombs[13],24, 24);//launches next bomb...
			ships[0].d = shipdsave + spread/2;
			ships[0].launchbomb(playerbombs[14],24, 24);
			ships[0].d = shipdsave + spread*1.5;
			ships[0].launchbomb(playerbombs[15],24, 24);		
			ships[0].d = shipdsave + spread*2.5;
			ships[0].launchbomb(playerbombs[16],24, 24);
			ships[0].d = shipdsave + spread*3.5;
			ships[0].launchbomb(playerbombs[17],24, 24);	
			ships[0].d = shipdsave + spread*4.5;
			ships[0].launchbomb(playerbombs[18],24, 24);	
			ships[0].d = shipdsave + spread*5.5;
			ships[0].launchbomb(playerbombs[19],24, 24);				
			ships[0].d = shipdsave;//restores original ship direction
			energy = energy - 60; 
			}
		}
	if (wep == 9){
		if ((energy > 75)&&(w9>0)){ //If ship has energy and weapon 4.
				ships[0].launchbomb(playerbombs[26],16, 120); 
				playerbombs[26].hp = 1000;//weapon 9 uses a special bomb that can bounce of planets				
				energy = energy - 60; 
			}
		}
	if (wep == 0){
		if ((energy > 75)&&(w0>0)){ //If ship has energy and weapon 4.
				ships[0].launchbomb(playerbombs[27],24, 120);  
				energy = energy - 50; 
			}
		}
	}
else if (mousestate==2){//if its the right button
	if (dockstate == 1){
		terranoutpost.undock(ships[0]);
		dockstate = 0;
		}
	if (dockstate == 2){
		merzoutpost.undock(ships[0]);
		dockstate = 0;
		}
	if (dockstate == 3){
		jupeoutpost.undock(ships[0]);
		dockstate = 0;
		}
	if (dockstate == 4){
		anusoutpost.undock(ships[0]);
		dockstate = 0;
		}
	ships[0].thrust = 2*thrustmultiplier;} //pushes player in direction this.d
	}
document.addEventListener("mouseup", mouseUpHandler, false);
function mouseUpHandler(e) {
mousestate = e.buttons;
}

    </script>
</body>
</html>